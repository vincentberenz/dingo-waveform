{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"dingo-waveform","text":"<p>dingo-waveform is a Python package for generating gravitational wave waveforms, designed as a refactored and optimized component of the dingo neural posterior estimation framework.</p>"},{"location":"#overview","title":"Overview","text":"<p>This package provides:</p> <ul> <li>Fast waveform generation for gravitational wave inference using LALSimulation</li> <li>Multiple domain support including uniform and multibanded frequency domains</li> <li>Mode-separated waveforms for higher-order spherical harmonic modes</li> <li>Interactive plotting for diagnostics and exploration</li> <li>Dataset generation tools for machine learning applications</li> <li>Command-line tools for verification and visualization</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#waveform-approximants","title":"Waveform Approximants","text":"<p>Support for state-of-the-art waveform models including:</p> <ul> <li>IMRPhenomXPHM - Precessing binary black holes with higher modes</li> <li>SEOBNRv5PHM - Effective-one-body with higher modes</li> <li>SEOBNRv5HM - Higher modes</li> <li>SEOBNRv4PHM - Previous generation with higher modes</li> <li>And more via LALSimulation</li> </ul>"},{"location":"#domain-types","title":"Domain Types","text":"<ul> <li>UniformFrequencyDomain - Standard uniform frequency sampling</li> <li>MultibandedFrequencyDomain - Efficient adaptive binning for neural networks</li> <li>TimeDomain - Time-domain waveform generation</li> </ul>"},{"location":"#visualization","title":"Visualization","text":"<p>Interactive plotting with Plotly for:</p> <ul> <li>Polarization waveforms (h\u208a, h\u00d7)</li> <li>Mode-separated waveforms</li> <li>Time-frequency representations (Q-transforms, spectrograms)</li> <li>Mode comparisons and reconstructions</li> </ul>"},{"location":"#command-line-tools","title":"Command-Line Tools","text":"<ul> <li><code>dingo-verify</code> - Verify correctness against dingo (dingo-gw)</li> <li><code>dingo-plot</code> - Generate interactive plots from configuration files</li> <li><code>dingo_generate_dataset</code> - Generate waveform datasets for training</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from dingo_waveform import (\n    WaveformGenerator,\n    WaveformParameters,\n    Approximant,\n    UniformFrequencyDomain\n)\n\n# Define domain\ndomain = UniformFrequencyDomain(\n    f_min=20.0,\n    f_max=1024.0,\n    delta_f=0.125\n)\n\n# Create generator\nwfg = WaveformGenerator(\n    approximant=Approximant(\"IMRPhenomXPHM\"),\n    domain=domain,\n    f_ref=20.0\n)\n\n# Set parameters\nparams = WaveformParameters(\n    mass_1=36.0,\n    mass_2=29.0,\n    luminosity_distance=1000.0,\n    theta_jn=0.5,\n    phase=0.0,\n    a_1=0.3,\n    a_2=0.2,\n    # ... other parameters\n)\n\n# Generate waveform\npolarization = wfg.generate_hplus_hcross(params)\n\n# Or generate mode-separated waveforms\nmodes = wfg.generate_hplus_hcross_m(params)\n</code></pre>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#gravitational-wave-inference","title":"Gravitational Wave Inference","text":"<p>Generate template waveforms for parameter estimation and matched filtering of gravitational wave signals from LIGO/Virgo/KAGRA detectors.</p>"},{"location":"#neural-posterior-estimation","title":"Neural Posterior Estimation","text":"<p>Efficiently generate training datasets for neural networks that perform rapid Bayesian inference on gravitational wave events.</p>"},{"location":"#waveform-diagnostics","title":"Waveform Diagnostics","text":"<p>Visualize and analyze waveform properties, compare approximants, and validate implementations.</p>"},{"location":"#related-projects","title":"Related Projects","text":"<ul> <li>dingo - Neural posterior estimation for gravitational waves</li> <li>LALSuite - LIGO Scientific Collaboration Algorithm Library</li> <li>bilby - Bayesian inference library</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use dingo-waveform in your research, please cite:</p> <p>Citation</p> <p>Citation information will be added here.</p>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Browse the sections in the navigation menu</li> <li>Issues: Report bugs or request features on GitHub Issues</li> <li>Examples: Check the Examples section for tutorials</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide - Get started with installation</li> <li>Quick Start - Your first waveform</li> <li>Concepts - Understand the core concepts</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"api/approximants/","title":"Approximants API","text":""},{"location":"api/dataset/","title":"Dataset API","text":""},{"location":"api/domains/","title":"Domains API","text":"<p>Domains define how waveforms are sampled in frequency or time.</p>"},{"location":"api/domains/#uniformfrequencydomain","title":"UniformFrequencyDomain","text":""},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain","title":"UniformFrequencyDomain","text":"<pre><code>UniformFrequencyDomain(f_min: float, f_max: float, delta_f: float, window_factor: Optional[float] = None)\n</code></pre> <p>               Bases: <code>BaseFrequencyDomain</code></p> <p>Represents a frequency domain with uniform bins.</p> <p>Immutable-style update:     - update(f_min=None, f_max=None, delta_f=None) -&gt; UniformFrequencyDomain       returns a new instance with an updated range (and optionally the same delta_f).       The current instance is not modified.</p> <p>Attributes:     f_min (float): Minimum frequency in Hz     f_max (float): Maximum frequency in Hz     delta_f (float): Frequency spacing in Hz     window_factor (Optional[float]): Window factor for noise calculations</p> <p>Initialize a UniformFrequencyDomain instance.</p> <p>Parameters:</p> Name Type Description Default <code>f_min</code> <code>float</code> <p>Minimum frequency in Hz.</p> required <code>f_max</code> <code>float</code> <p>Maximum frequency in Hz.</p> required <code>delta_f</code> <code>float</code> <p>Frequency spacing in Hz.</p> required <code>window_factor</code> <code>Optional[float]</code> <p>Window factor for noise calculations.</p> <code>None</code>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.min_idx","title":"min_idx  <code>property</code>","text":"<pre><code>min_idx: int\n</code></pre> <p>Return the minimum index of the domain.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.max_idx","title":"max_idx  <code>property</code>","text":"<pre><code>max_idx: int\n</code></pre> <p>Return the maximum index of the domain.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.window_factor","title":"window_factor  <code>property</code> <code>writable</code>","text":"<pre><code>window_factor\n</code></pre> <p>Get the window factor for noise calculations.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.noise_std","title":"noise_std  <code>property</code>","text":"<pre><code>noise_std: float\n</code></pre> <p>Return the standard deviation of the whitened noise distribution.</p> <p>To have noise that comes from a multivariate unit normal distribution, divide waveforms by this factor.</p> <p>Raises:</p> Type Description <code>ValueError if window factor is not set.</code>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.f_max","title":"f_max  <code>property</code> <code>writable</code>","text":"<pre><code>f_max: float\n</code></pre> <p>Return the maximum frequency.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.f_min","title":"f_min  <code>property</code> <code>writable</code>","text":"<pre><code>f_min: float\n</code></pre> <p>Return the minimum frequency.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.delta_f","title":"delta_f  <code>property</code> <code>writable</code>","text":"<pre><code>delta_f: float\n</code></pre> <p>Return the frequency spacing.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.duration","title":"duration  <code>property</code>","text":"<pre><code>duration: float\n</code></pre> <p>Return the duration.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.sampling_rate","title":"sampling_rate  <code>property</code>","text":"<pre><code>sampling_rate: float\n</code></pre> <p>Return the sampling rate.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.sample_frequencies_torch","title":"sample_frequencies_torch  <code>property</code>","text":"<pre><code>sample_frequencies_torch: Tensor\n</code></pre> <p>Return the sample frequencies as a PyTorch tensor.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.sample_frequencies_torch_cuda","title":"sample_frequencies_torch_cuda  <code>property</code>","text":"<pre><code>sample_frequencies_torch_cuda: Tensor\n</code></pre> <p>Return the sample frequencies as a CUDA tensor.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.frequency_mask","title":"frequency_mask  <code>property</code>","text":"<pre><code>frequency_mask: ndarray\n</code></pre> <p>Return mask which selects frequency bins greater than or equal to the starting frequency.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.frequency_mask_length","title":"frequency_mask_length  <code>property</code>","text":"<pre><code>frequency_mask_length: int\n</code></pre> <p>Return number of samples in the subdomain domain[frequency_mask].</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.get_parameters","title":"get_parameters","text":"<pre><code>get_parameters() -&gt; DomainParameters\n</code></pre> <p>Get the parameters of the frequency domain.</p> <p>Returns:</p> Type Description <code>DomainParameters</code> <p>The parameters of the frequency domain. Note: delta_t is computed as <code>0.5 / f_max</code>.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.from_parameters","title":"from_parameters  <code>classmethod</code>","text":"<pre><code>from_parameters(domain_parameters: DomainParameters) -&gt; UniformFrequencyDomain\n</code></pre> <p>Create a FrequencyDomain instance from given parameters.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.update","title":"update","text":"<pre><code>update(f_min: Optional[float] = None, f_max: Optional[float] = None, delta_f: Optional[float] = None) -&gt; UniformFrequencyDomain\n</code></pre> <p>Return a new UniformFrequencyDomain with an updated range (and same delta_f).</p> Rules <ul> <li>delta_f changes are not allowed (must be None or equal to current delta_f).</li> <li>The new range must be contained within the current one:     f_min_new &gt;= self.f_min and f_max_new &lt;= self.f_max.</li> <li>Also enforces f_min_new &lt; f_max_new.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>f_min</code> <code>Optional[float]</code> <p>New minimum frequency (None to keep current value).</p> <code>None</code> <code>f_max</code> <code>Optional[float]</code> <p>New maximum frequency (None to keep current value).</p> <code>None</code> <code>delta_f</code> <code>Optional[float]</code> <p>New frequency spacing (must be None or equal to current value).</p> <code>None</code> <p>Returns:</p> Type Description <code>UniformFrequencyDomain</code> <p>A new instance with the requested range.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If updated values violate domain constraints.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.time_translate_data","title":"time_translate_data","text":"<pre><code>time_translate_data(data: Union[ndarray, Tensor], dt: Union[float, Tensor]) -&gt; Union[np.ndarray, torch.Tensor]\n</code></pre> <p>Time translate frequency-domain data by dt seconds.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Return the number of frequency bins in the domain [0, f_max].</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.__call__","title":"__call__","text":"<pre><code>__call__() -&gt; np.ndarray\n</code></pre> <p>Return array of uniform frequency bins in the domain [0, f_max].</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.sample_frequencies","title":"sample_frequencies","text":"<pre><code>sample_frequencies() -&gt; np.ndarray\n</code></pre> <p>Return the sample frequencies.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(idx)\n</code></pre> <p>Return slice of uniform frequency grid.</p>"},{"location":"api/domains/#dingo_waveform.domains.UniformFrequencyDomain.update_data","title":"update_data","text":"<pre><code>update_data(data: ndarray, axis: int = -1, low_value: float = 0.0) -&gt; np.ndarray\n</code></pre> <p>Adjust data to be compatible with the domain: truncate above f_max, and set values below f_min to low_value.</p>"},{"location":"api/domains/#multibandedfrequencydomain","title":"MultibandedFrequencyDomain","text":""},{"location":"api/domains/#dingo_waveform.domains.MultibandedFrequencyDomain","title":"MultibandedFrequencyDomain","text":"<pre><code>MultibandedFrequencyDomain(nodes: Iterable[float], delta_f_initial: float, base_delta_f: float, window_factor: Optional[float] = None)\n</code></pre> <p>               Bases: <code>BaseFrequencyDomain</code></p> <p>Non-uniform frequency domain composed of dyadically spaced uniform bands.</p> <p>Immutable-style API:   - narrowed(f_min, f_max) -&gt; MultibandedFrequencyDomain returns a new instance.   - slice_from(old_domain, data, axis=-1) slices old-domain-aligned data to this domain.</p> <p>Internals:   - self._binning: BinningParameters (authoritative, immutable band/bin metadata)   - base_delta_f: Base uniform frequency spacing for binning calculations   - sample frequencies are the per-bin midpoints of [f_base_lower, f_base_upper]</p> <p>Initialize a MultibandedFrequencyDomain with dyadic spacing.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>Iterable[float]</code> <p>Band boundary frequencies. Must have at least 2 elements.</p> required <code>delta_f_initial</code> <code>float</code> <p>Frequency spacing for the first (lowest frequency) band.</p> required <code>base_delta_f</code> <code>float</code> <p>Base uniform frequency spacing used for binning calculations.</p> required <code>window_factor</code> <code>Optional[float]</code> <p>Optional window factor (preserved for narrowing operations).</p> <code>None</code>"},{"location":"api/domains/#dingo_waveform.domains.MultibandedFrequencyDomain.bands","title":"bands  <code>property</code>","text":"<pre><code>bands: Tuple[Band, ...]\n</code></pre> <p>Tuple of per-band metadata objects.</p>"},{"location":"api/domains/#dingo_waveform.domains.MultibandedFrequencyDomain.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes: ndarray\n</code></pre> <p>Copy of the band boundary nodes (shape: num_bands + 1, dtype float32).</p>"},{"location":"api/domains/#dingo_waveform.domains.MultibandedFrequencyDomain.waveform_transform","title":"waveform_transform","text":"<pre><code>waveform_transform(polarizations: Polarization) -&gt; Polarization\n</code></pre> <p>Transform waveform polarizations from base uniform grid to multibanded representation.</p> <p>This method decimates waveforms generated on a uniform frequency grid (starting at f=0) to the sparse multibanded grid representation of this domain. It uses adaptive binning with dyadic spacing to efficiently represent the waveform.</p> <p>Parameters:</p> Name Type Description Default <code>polarizations</code> <code>Polarization</code> <p>Polarization waveforms (h_plus, h_cross) on uniform grid. Expected to be generated on a uniform grid starting at f=0 with spacing base_delta_f.</p> required <p>Returns:</p> Type Description <code>Polarization</code> <p>Decimated polarizations matching this domain's multibanded binning structure.</p> Notes <p>The input waveforms should be generated on a uniform frequency grid that: - Starts at f=0 - Has frequency spacing equal to self.base_delta_f - Covers at least up to self.f_max</p> <p>The decimation uses mode='explicit' assuming data starts at f=0.</p>"},{"location":"api/domains/#dingo_waveform.domains.MultibandedFrequencyDomain.narrowed","title":"narrowed","text":"<pre><code>narrowed(f_min: Optional[float] = None, f_max: Optional[float] = None) -&gt; MultibandedFrequencyDomain\n</code></pre> <p>Return a new MultibandedFrequencyDomain narrowed to [f_min, f_max] within this domain. The current instance is not modified.</p> Notes <ul> <li>f_min/f_max refer to the base grid range.</li> <li>Preserves the dyadic structure by choosing the new delta_f_initial from   the band that becomes the new first band.</li> </ul>"},{"location":"api/domains/#dingo_waveform.domains.MultibandedFrequencyDomain.decimate","title":"decimate","text":"<pre><code>decimate(data: Union[ndarray, Tensor], mode: str = 'auto') -&gt; Union[np.ndarray, torch.Tensor]\n</code></pre> <p>Decimate data from the base uniform grid to this multi-banded domain.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray | Tensor</code> <p>Input data to decimate along last axis.</p> required <code>mode</code> <code>(auto, explicit)</code> <ul> <li>\"auto\": Infer base_offset_idx from data length.</li> <li>\"explicit\": Use base_offset_idx=0 (assumes data starts at f=0).</li> </ul> <code>\"auto\"</code> <p>Returns:</p> Type Description <code>Decimated data matching this domain's binning.</code>"},{"location":"api/domains/#dingo_waveform.domains.MultibandedFrequencyDomain.time_translate_data","title":"time_translate_data","text":"<pre><code>time_translate_data(data: Union[ndarray, Tensor], dt: Union[float, Tensor]) -&gt; Union[np.ndarray, torch.Tensor]\n</code></pre> <p>Time translate frequency-domain data by dt seconds.</p>"},{"location":"api/domains/#timedomain","title":"TimeDomain","text":""},{"location":"api/domains/#dingo_waveform.domains.TimeDomain","title":"TimeDomain","text":"<pre><code>TimeDomain(time_duration: float, sampling_rate: float)\n</code></pre> <p>               Bases: <code>Domain</code></p> <p>Defines the physical time domain on which the data of interest live.</p> <p>The time bins are assumed to be uniform between [0, duration] with spacing 1 / sampling_rate. window_factor is used to compute noise_std().</p> <p>Initialize a TimeDomain instance.</p> <p>Parameters:</p> Name Type Description Default <code>time_duration</code> <code>float</code> <p>Duration of the time domain in seconds.</p> required <code>sampling_rate</code> <code>float</code> <p>Sampling rate in Hz.</p> required"},{"location":"api/domains/#dingo_waveform.domains.TimeDomain.delta_t","title":"delta_t  <code>property</code> <code>writable</code>","text":"<pre><code>delta_t: float\n</code></pre> <p>The size of the time bins.</p> <p>Returns:</p> Type Description <code>float</code> <p>Size of the time bins.</p>"},{"location":"api/domains/#dingo_waveform.domains.TimeDomain.noise_std","title":"noise_std  <code>property</code>","text":"<pre><code>noise_std: float\n</code></pre> <p>Standard deviation of the whitened noise distribution.</p> <p>To have noise that comes from a multivariate unit normal distribution, you must divide by this factor. In practice, this means dividing the whitened waveforms by this.</p> <p>In the continuum limit in time domain, the standard deviation of white noise would at each point go to infinity, hence the delta_t factor.</p> <p>Returns:</p> Type Description <code>float</code> <p>Standard deviation of the whitened noise distribution.</p>"},{"location":"api/domains/#dingo_waveform.domains.TimeDomain.f_max","title":"f_max  <code>property</code>","text":"<pre><code>f_max: float\n</code></pre> <p>The maximum frequency [Hz] is typically set to half the sampling rate.</p> <p>Returns:</p> Type Description <code>float</code> <p>Maximum frequency in Hz.</p>"},{"location":"api/domains/#dingo_waveform.domains.TimeDomain.duration","title":"duration  <code>property</code>","text":"<pre><code>duration: float\n</code></pre> <p>Waveform duration in seconds.</p> <p>Returns:</p> Type Description <code>float</code> <p>Duration of the waveform.</p>"},{"location":"api/domains/#dingo_waveform.domains.TimeDomain.sampling_rate","title":"sampling_rate  <code>property</code>","text":"<pre><code>sampling_rate: float\n</code></pre> <p>Returns the sampling rate.</p>"},{"location":"api/domains/#dingo_waveform.domains.TimeDomain.min_idx","title":"min_idx  <code>property</code>","text":"<pre><code>min_idx: int\n</code></pre> <p>Return the minimum index of the domain.</p>"},{"location":"api/domains/#dingo_waveform.domains.TimeDomain.max_idx","title":"max_idx  <code>property</code>","text":"<pre><code>max_idx: int\n</code></pre> <p>Return the maximum index of the domain.</p>"},{"location":"api/domains/#dingo_waveform.domains.TimeDomain.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>TimeDomain does not support update.</p> <p>Raises:</p> Type Description <code>A NotImplementedError</code>"},{"location":"api/domains/#dingo_waveform.domains.TimeDomain.__len__","title":"__len__  <code>cached</code>","text":"<pre><code>__len__()\n</code></pre> <p>Number of time bins given duration and sampling rate.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of time bins.</p>"},{"location":"api/domains/#dingo_waveform.domains.TimeDomain.__call__","title":"__call__  <code>cached</code>","text":"<pre><code>__call__() -&gt; np.ndarray\n</code></pre> <p>Array of uniform times at which data is sampled.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of uniform times.</p>"},{"location":"api/domains/#dingo_waveform.domains.TimeDomain.get_parameters","title":"get_parameters","text":"<pre><code>get_parameters() -&gt; DomainParameters\n</code></pre> <p>Returns the corresponding instance of DomainParameters, filling the fields delta_t, f_max, time_duration and sampling_rate.</p>"},{"location":"api/domains/#dingo_waveform.domains.TimeDomain.from_parameters","title":"from_parameters  <code>classmethod</code>","text":"<pre><code>from_parameters(domain_parameters: DomainParameters) -&gt; TimeDomain\n</code></pre> <p>Construct an instance of TimeDomain from the parameters. It uses the fields time_duration and sampling_rate, which should not be None</p> <p>Raises:</p> Type Description <code>A ValueError if either the file time_duration or sampling_rate is None.</code>"},{"location":"api/domains/#usage-examples","title":"Usage Examples","text":""},{"location":"api/domains/#uniform-frequency-domain","title":"Uniform Frequency Domain","text":"<pre><code>from dingo_waveform import UniformFrequencyDomain\n\ndomain = UniformFrequencyDomain(\n    f_min=20.0,      # Minimum frequency (Hz)\n    f_max=1024.0,    # Maximum frequency (Hz)\n    delta_f=0.125    # Frequency spacing (Hz)\n)\n\n# Get frequency array\nfreqs = domain()\nprint(f\"Number of frequency bins: {len(freqs)}\")\n</code></pre>"},{"location":"api/domains/#multibanded-frequency-domain","title":"Multibanded Frequency Domain","text":"<pre><code>from dingo_waveform import MultibandedFrequencyDomain\n\ndomain = MultibandedFrequencyDomain(\n    f_min=20.0,\n    f_max=1024.0,\n    delta_f_initial=0.125,\n    n_bins_per_harmonic=6\n)\n\n# Adaptive binning for efficiency\nfreqs = domain.sample_frequencies\nprint(f\"Reduced to {len(freqs)} bins (from ~{int(1024/0.125)})\")\n</code></pre>"},{"location":"api/domains/#time-domain","title":"Time Domain","text":"<pre><code>from dingo_waveform import TimeDomain\n\ndomain = TimeDomain(\n    duration=8.0,       # Total duration (seconds)\n    delta_t=1/2048.0    # Time step (seconds)\n)\n\n# Get time array\ntimes = domain()\nprint(f\"Number of time samples: {len(times)}\")\n</code></pre>"},{"location":"api/domains/#see-also","title":"See Also","text":"<ul> <li>Concepts: Domains - Detailed explanation of domains</li> <li>Waveform Generator API - Using domains with generators</li> </ul>"},{"location":"api/plotting/","title":"Plotting API","text":"<p>Interactive plotting functions for waveform visualization.</p>"},{"location":"api/plotting/#polarization-plots","title":"Polarization Plots","text":"<p>Functions for plotting basic polarizations from <code>generate_hplus_hcross()</code>.</p>"},{"location":"api/plotting/#plot_polarizations_frequency","title":"plot_polarizations_frequency","text":""},{"location":"api/plotting/#dingo_waveform.plotting.plot_polarizations_frequency","title":"plot_polarizations_frequency","text":"<pre><code>plot_polarizations_frequency(polarization: Polarization, domain: BaseFrequencyDomain, title: str = 'Gravitational Wave Polarizations (Frequency Domain)', plot_type: Literal['amplitude', 'phase', 'both'] = 'amplitude', log_scale: bool = True, height: int = 500) -&gt; go.Figure\n</code></pre> <p>Interactive frequency-domain plot with amplitude and/or phase.</p> <p>Parameters:</p> Name Type Description Default <code>polarization</code> <code>Polarization</code> <p>Polarization object containing frequency-domain h_plus and h_cross</p> required <code>domain</code> <code>BaseFrequencyDomain</code> <p>Frequency domain specification</p> required <code>title</code> <code>str</code> <p>Plot title</p> <code>'Gravitational Wave Polarizations (Frequency Domain)'</code> <code>plot_type</code> <code>(amplitude, phase, both)</code> <p>What to plot: amplitude, phase, or both</p> <code>'amplitude'</code> <code>log_scale</code> <code>bool</code> <p>Use log scale for y-axis (amplitude) and x-axis (frequency)</p> <code>True</code> <code>height</code> <code>int</code> <p>Figure height in pixels</p> <code>500</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Interactive plotly figure</p>"},{"location":"api/plotting/#plot_polarizations_time","title":"plot_polarizations_time","text":""},{"location":"api/plotting/#dingo_waveform.plotting.plot_polarizations_time","title":"plot_polarizations_time","text":"<pre><code>plot_polarizations_time(polarization: Polarization, domain: TimeDomain, title: str = 'Gravitational Wave Polarizations (Time Domain)', show_both: bool = True, height: int = 500) -&gt; go.Figure\n</code></pre> <p>Interactive time-domain plot of h+ and h\u00d7 strain.</p> <p>Parameters:</p> Name Type Description Default <code>polarization</code> <code>Polarization</code> <p>Polarization object containing h_plus and h_cross</p> required <code>domain</code> <code>TimeDomain</code> <p>Time domain specification</p> required <code>title</code> <code>str</code> <p>Plot title</p> <code>'Gravitational Wave Polarizations (Time Domain)'</code> <code>show_both</code> <code>bool</code> <p>If True, show both h+ and h\u00d7 on same plot. If False, create subplots.</p> <code>True</code> <code>height</code> <code>int</code> <p>Figure height in pixels</p> <code>500</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Interactive plotly figure</p>"},{"location":"api/plotting/#plot_polarization_spectrogram","title":"plot_polarization_spectrogram","text":""},{"location":"api/plotting/#dingo_waveform.plotting.plot_polarization_spectrogram","title":"plot_polarization_spectrogram","text":"<pre><code>plot_polarization_spectrogram(polarization: Polarization, domain: Domain, polarization_type: Literal['plus', 'cross', 'both'] = 'plus', fftlength: float = 0.1, title: Optional[str] = None, height: int = 500) -&gt; go.Figure\n</code></pre> <p>Time-frequency spectrogram using Short-Time Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>polarization</code> <code>Polarization</code> <p>Polarization object</p> required <code>domain</code> <code>Domain</code> <p>Domain specification (will convert to time domain if needed)</p> required <code>polarization_type</code> <code>(plus, cross, both)</code> <p>Which polarization to plot</p> <code>'plus'</code> <code>fftlength</code> <code>float</code> <p>FFT window length in seconds</p> <code>0.1</code> <code>title</code> <code>str</code> <p>Plot title (auto-generated if None)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels</p> <code>500</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Interactive plotly figure with spectrogram</p>"},{"location":"api/plotting/#plot_polarization_qtransform","title":"plot_polarization_qtransform","text":""},{"location":"api/plotting/#dingo_waveform.plotting.plot_polarization_qtransform","title":"plot_polarization_qtransform","text":"<pre><code>plot_polarization_qtransform(polarization: Polarization, domain: Domain, polarization_type: Literal['plus', 'cross', 'both'] = 'plus', qrange: tuple[float, float] = (4.0, 64.0), title: Optional[str] = None, height: int = 500) -&gt; go.Figure\n</code></pre> <p>Q-transform time-frequency representation.</p> <p>The Q-transform is optimized for detecting transient signals like gravitational wave mergers. It provides better time-frequency resolution than standard spectrograms.</p> <p>Parameters:</p> Name Type Description Default <code>polarization</code> <code>Polarization</code> <p>Polarization object</p> required <code>domain</code> <code>Domain</code> <p>Domain specification (will convert to time domain if needed)</p> required <code>polarization_type</code> <code>(plus, cross, both)</code> <p>Which polarization to plot</p> <code>'plus'</code> <code>qrange</code> <code>tuple of float</code> <p>(Q_min, Q_max) for Q-transform</p> <code>(4.0, 64.0)</code> <code>title</code> <code>str</code> <p>Plot title (auto-generated if None)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels</p> <code>500</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Interactive plotly figure with Q-transform</p>"},{"location":"api/plotting/#mode-plots","title":"Mode Plots","text":"<p>Functions for plotting mode-separated waveforms from <code>generate_hplus_hcross_m()</code>.</p>"},{"location":"api/plotting/#plot_mode_amplitudes","title":"plot_mode_amplitudes","text":""},{"location":"api/plotting/#dingo_waveform.plotting.plot_mode_amplitudes","title":"plot_mode_amplitudes","text":"<pre><code>plot_mode_amplitudes(modes: Dict[Mode, Polarization], domain: Domain, frequency: Optional[float] = None, polarization_type: Literal['plus', 'cross'] = 'plus', title: Optional[str] = None, height: int = 500) -&gt; go.Figure\n</code></pre> <p>Bar chart or heatmap of mode amplitudes.</p> <p>Parameters:</p> Name Type Description Default <code>modes</code> <code>Dict[Mode, Polarization]</code> <p>Mode-separated polarizations from generate_hplus_hcross_m</p> required <code>domain</code> <code>Domain</code> <p>Domain specification</p> required <code>frequency</code> <code>float</code> <p>Specific frequency to evaluate (Hz). If None, uses maximum over all frequencies.</p> <code>None</code> <code>polarization_type</code> <code>(plus, cross)</code> <p>Which polarization to analyze</p> <code>'plus'</code> <code>title</code> <code>str</code> <p>Plot title (auto-generated if None)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels</p> <code>500</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Interactive bar chart with mode amplitudes</p>"},{"location":"api/plotting/#plot_individual_modes","title":"plot_individual_modes","text":""},{"location":"api/plotting/#dingo_waveform.plotting.plot_individual_modes","title":"plot_individual_modes","text":"<pre><code>plot_individual_modes(modes: Dict[Mode, Polarization], domain: Domain, mode_list: Optional[List[Mode]] = None, domain_type: Literal['time', 'frequency'] = 'frequency', polarization_type: Literal['plus', 'cross'] = 'plus', title: Optional[str] = None, height: int = 600) -&gt; go.Figure\n</code></pre> <p>Plot individual modes as separate traces on the same axes.</p> <p>Interactive legend allows toggling modes on/off.</p> <p>Parameters:</p> Name Type Description Default <code>modes</code> <code>Dict[Mode, Polarization]</code> <p>Mode-separated polarizations from generate_hplus_hcross_m</p> required <code>domain</code> <code>Domain</code> <p>Domain specification</p> required <code>mode_list</code> <code>List[Mode]</code> <p>Specific modes to plot. If None, plot all modes.</p> <code>None</code> <code>domain_type</code> <code>(time, frequency)</code> <p>Whether to plot in time or frequency domain</p> <code>'time'</code> <code>polarization_type</code> <code>(plus, cross)</code> <p>Which polarization to plot</p> <code>'plus'</code> <code>title</code> <code>str</code> <p>Plot title (auto-generated if None)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels</p> <code>600</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Interactive plotly figure with all modes</p>"},{"location":"api/plotting/#plot_mode_comparison","title":"plot_mode_comparison","text":""},{"location":"api/plotting/#dingo_waveform.plotting.plot_mode_comparison","title":"plot_mode_comparison","text":"<pre><code>plot_mode_comparison(modes: Dict[Mode, Polarization], domain: Domain, reference_mode: Mode = (2, 2), metric: Literal['amplitude_ratio', 'phase_difference'] = 'amplitude_ratio', polarization_type: Literal['plus', 'cross'] = 'plus', title: Optional[str] = None, height: int = 600) -&gt; go.Figure\n</code></pre> <p>Compare all modes against a reference mode.</p> <p>Parameters:</p> Name Type Description Default <code>modes</code> <code>Dict[Mode, Polarization]</code> <p>Mode-separated polarizations</p> required <code>domain</code> <code>Domain</code> <p>Domain specification</p> required <code>reference_mode</code> <code>Mode</code> <p>Mode to use as reference for comparison</p> <code>(2, 2)</code> <code>metric</code> <code>(amplitude_ratio, phase_difference)</code> <p>What to compare: amplitude ratios or phase differences</p> <code>'amplitude_ratio'</code> <code>polarization_type</code> <code>(plus, cross)</code> <p>Which polarization to analyze</p> <code>'plus'</code> <code>title</code> <code>str</code> <p>Plot title (auto-generated if None)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels</p> <code>600</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Interactive comparison plot</p>"},{"location":"api/plotting/#plot_modes_grid","title":"plot_modes_grid","text":""},{"location":"api/plotting/#dingo_waveform.plotting.plot_modes_grid","title":"plot_modes_grid","text":"<pre><code>plot_modes_grid(modes: Dict[Mode, Polarization], domain: Domain, domain_type: Literal['time', 'frequency'] = 'frequency', polarization_type: Literal['plus', 'cross'] = 'plus', title: Optional[str] = None) -&gt; go.Figure\n</code></pre> <p>Grid of subplots, one per mode. Good for getting an overview.</p> <p>Parameters:</p> Name Type Description Default <code>modes</code> <code>Dict[Mode, Polarization]</code> <p>Mode-separated polarizations</p> required <code>domain</code> <code>Domain</code> <p>Domain specification</p> required <code>domain_type</code> <code>(time, frequency)</code> <p>Whether to plot in time or frequency domain</p> <code>'time'</code> <code>polarization_type</code> <code>(plus, cross)</code> <p>Which polarization to plot</p> <code>'plus'</code> <code>title</code> <code>str</code> <p>Plot title (auto-generated if None)</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Grid plot with all modes</p>"},{"location":"api/plotting/#plot_mode_reconstruction","title":"plot_mode_reconstruction","text":""},{"location":"api/plotting/#dingo_waveform.plotting.plot_mode_reconstruction","title":"plot_mode_reconstruction","text":"<pre><code>plot_mode_reconstruction(modes: Dict[Mode, Polarization], domain: Domain, selected_modes: Optional[List[Mode]] = None, phase_shift: float = 0.0, domain_type: Literal['time', 'frequency'] = 'frequency', title: Optional[str] = None, height: int = 600) -&gt; go.Figure\n</code></pre> <p>Reconstruct total h+/h\u00d7 from selected modes and compare to full sum.</p> <p>This is useful for understanding which modes contribute most to the total waveform.</p> <p>Parameters:</p> Name Type Description Default <code>modes</code> <code>Dict[Mode, Polarization]</code> <p>Mode-separated polarizations</p> required <code>domain</code> <code>Domain</code> <p>Domain specification</p> required <code>selected_modes</code> <code>List[Mode]</code> <p>Modes to include in reconstruction. If None, use all modes.</p> <code>None</code> <code>phase_shift</code> <code>float</code> <p>Phase shift to apply when summing modes (radians)</p> <code>0.0</code> <code>domain_type</code> <code>(time, frequency)</code> <p>Whether to plot in time or frequency domain</p> <code>'time'</code> <code>title</code> <code>str</code> <p>Plot title (auto-generated if None)</p> <code>None</code> <code>height</code> <code>int</code> <p>Figure height in pixels</p> <code>600</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Comparison of partial and full reconstruction</p>"},{"location":"api/plotting/#converter-functions","title":"Converter Functions","text":"<p>Advanced functions for converting to gwpy formats.</p>"},{"location":"api/plotting/#polarization_to_gwpy_timeseries","title":"polarization_to_gwpy_timeseries","text":""},{"location":"api/plotting/#dingo_waveform.plotting.polarization_to_gwpy_timeseries","title":"polarization_to_gwpy_timeseries","text":"<pre><code>polarization_to_gwpy_timeseries(polarization: Polarization, domain: TimeDomain) -&gt; Tuple[gwpy.timeseries.TimeSeries, gwpy.timeseries.TimeSeries]\n</code></pre> <p>Convert dingo-waveform Polarization to gwpy TimeSeries objects.</p> <p>Parameters:</p> Name Type Description Default <code>polarization</code> <code>Polarization</code> <p>Polarization with h_plus and h_cross arrays</p> required <code>domain</code> <code>TimeDomain</code> <p>Time domain specification</p> required <p>Returns:</p> Type Description <code>Tuple[TimeSeries, TimeSeries]</code> <p>(h_plus_ts, h_cross_ts) as gwpy TimeSeries objects</p>"},{"location":"api/plotting/#polarization_to_gwpy_frequencyseries","title":"polarization_to_gwpy_frequencyseries","text":""},{"location":"api/plotting/#dingo_waveform.plotting.polarization_to_gwpy_frequencyseries","title":"polarization_to_gwpy_frequencyseries","text":"<pre><code>polarization_to_gwpy_frequencyseries(polarization: Polarization, domain: BaseFrequencyDomain) -&gt; Tuple[gwpy.frequencyseries.FrequencySeries, gwpy.frequencyseries.FrequencySeries]\n</code></pre> <p>Convert dingo-waveform Polarization to gwpy FrequencySeries objects.</p> <p>Parameters:</p> Name Type Description Default <code>polarization</code> <code>Polarization</code> <p>Polarization with h_plus and h_cross frequency-domain arrays</p> required <code>domain</code> <code>BaseFrequencyDomain</code> <p>Frequency domain specification (UniformFrequencyDomain or MultibandedFrequencyDomain)</p> required <p>Returns:</p> Type Description <code>Tuple[FrequencySeries, FrequencySeries]</code> <p>(h_plus_fs, h_cross_fs) as gwpy FrequencySeries objects</p>"},{"location":"api/plotting/#usage-examples","title":"Usage Examples","text":""},{"location":"api/plotting/#basic-frequency-domain-plot","title":"Basic Frequency Domain Plot","text":"<pre><code>from dingo_waveform import WaveformGenerator, UniformFrequencyDomain\nfrom dingo_waveform.plotting import plot_polarizations_frequency\n\n# Generate waveform (see Waveform Generator API)\nwfg = WaveformGenerator(...)\npol = wfg.generate_hplus_hcross(params)\n\n# Plot\nfig = plot_polarizations_frequency(\n    pol,\n    wfg.domain,\n    plot_type=\"amplitude\",\n    log_scale=True\n)\n\n# Display\nfig.show()\n\n# Or save\nfig.write_html(\"waveform.html\")\n</code></pre>"},{"location":"api/plotting/#mode-amplitude-comparison","title":"Mode Amplitude Comparison","text":"<pre><code>from dingo_waveform.plotting import plot_mode_amplitudes\n\n# Generate modes\nmodes = wfg.generate_hplus_hcross_m(params)\n\n# Plot amplitude comparison\nfig = plot_mode_amplitudes(modes, wfg.domain)\nfig.show()\n</code></pre>"},{"location":"api/plotting/#all-modes-overlaid","title":"All Modes Overlaid","text":"<pre><code>from dingo_waveform.plotting import plot_individual_modes\n\nfig = plot_individual_modes(\n    modes,\n    wfg.domain,\n    domain_type=\"frequency\",\n    polarization_type=\"plus\"\n)\nfig.show()\n</code></pre>"},{"location":"api/plotting/#plot-customization","title":"Plot Customization","text":"<p>All plotting functions return Plotly <code>Figure</code> objects that can be further customized:</p> <pre><code>fig = plot_polarizations_frequency(pol, domain)\n\n# Update layout\nfig.update_layout(\n    title=\"My Custom Title\",\n    width=1200,\n    height=600,\n    font=dict(size=14)\n)\n\n# Update axes\nfig.update_xaxes(title_text=\"Frequency (Hz)\")\nfig.update_yaxes(title_text=\"Strain\")\n\nfig.show()\n</code></pre>"},{"location":"api/plotting/#see-also","title":"See Also","text":"<ul> <li>CLI: dingo-plot - Command-line plotting tool</li> <li>Examples: Plotting - More plotting examples</li> </ul>"},{"location":"api/polarizations/","title":"Polarizations API","text":""},{"location":"api/waveform-generator/","title":"Waveform Generator API","text":"<p>The <code>WaveformGenerator</code> class is the main interface for generating gravitational wave waveforms.</p>"},{"location":"api/waveform-generator/#waveformgenerator","title":"WaveformGenerator","text":""},{"location":"api/waveform-generator/#dingo_waveform.waveform_generator.WaveformGenerator","title":"WaveformGenerator","text":"<pre><code>WaveformGenerator(approximant: Approximant, domain: Domain, f_ref: float, f_start: Optional[float] = None, spin_conversion_phase: Optional[float] = None, mode_list: Optional[List[Modes]] = None, transform: Optional[Union[str, Callable[[Polarization], Polarization]]] = None, polarization_function: Optional[Union[str, PolarizationFunction]] = None, polarization_modes_function: Optional[Union[str, PolarizationModesFunction]] = None)\n</code></pre> <p>A class for generating gravitational wave polarizations using various waveform approximants and domains. This class serves as a wrapper around the PolarizationFunction and PolarizationModesFunction types, automatically selecting the appropriate function based on the specified approximant and domain.</p> <p>Methods:</p> Name Description <code>generate_hplus_hcross</code> <p>Generate h+ and h\u00d7 polarizations for a given set of parameters</p> <code>generate_hplus_hcross_m</code> <p>Generate h+ and h\u00d7 polarizations for multiple modes</p> <p>Initialize the WaveformGenerator with the necessary parameters.</p> <p>Parameters:</p> Name Type Description Default <code>approximant</code> <code>Approximant</code> <p>The waveform approximant model to use (e.g., SEOBNRv5, IMRPhenomD)</p> required <code>domain</code> <code>Domain</code> <p>The computational domain for the waveform generation</p> required <code>f_ref</code> <code>float</code> <p>Reference frequency for the waveform generation</p> required <code>f_start</code> <code>Optional[float]</code> <p>Starting frequency for the waveform generation</p> <code>None</code> <code>spin_conversion_phase</code> <code>Optional[float]</code> <p>Phase angle used for converting spins</p> <code>None</code> <code>mode_list</code> <code>Optional[List[Modes]]</code> <p>List of (ell, m) tuples specifying the spherical harmonic modes</p> <code>None</code> <code>transform</code> <code>Optional[Union[str, Callable[[Polarization], Polarization]]]</code> <p>Optional transformation function to apply to the generated polarizations. Passed as the function itself or as an import path.</p> <code>None</code> <code>polarization_function</code> <code>Optional[Union[str, PolarizationFunction]]</code> <p>Either a string representing the import path of a function to use, or the function itself to generate single polarization waveforms</p> <code>None</code> <code>polarization_modes_function</code> <code>Optional[Union[str, PolarizationModesFunction]]</code> <p>Either a string representing the import path of a function to use, or the function itself to generate multiple polarization modes</p> <code>None</code> Source code in <code>dingo_waveform/waveform_generator.py</code> <pre><code>def __init__(\n    self,\n    approximant: Approximant,\n    domain: Domain,\n    f_ref: float,\n    f_start: Optional[float] = None,\n    spin_conversion_phase: Optional[float] = None,\n    mode_list: Optional[List[Modes]] = None,\n    transform: Optional[Union[str, Callable[[Polarization], Polarization]]] = None,\n    polarization_function: Optional[Union[str, PolarizationFunction]] = None,\n    polarization_modes_function: Optional[\n        Union[str, PolarizationModesFunction]\n    ] = None,\n):\n    \"\"\"\n    Initialize the WaveformGenerator with the necessary parameters.\n\n    Parameters\n    ----------\n    approximant :\n        The waveform approximant model to use (e.g., SEOBNRv5, IMRPhenomD)\n    domain :\n        The computational domain for the waveform generation\n    f_ref :\n        Reference frequency for the waveform generation\n    f_start :\n        Starting frequency for the waveform generation\n    spin_conversion_phase :\n        Phase angle used for converting spins\n    mode_list :\n        List of (ell, m) tuples specifying the spherical harmonic modes\n    transform :\n        Optional transformation function to apply to the generated polarizations.\n        Passed as the function itself or as an import path.\n    polarization_function :\n        Either a string representing the import path of a function to use, or\n        the function itself to generate single polarization waveforms\n    polarization_modes_function :\n        Either a string representing the import path of a function to use, or\n        the function itself to generate multiple polarization modes\n    \"\"\"\n\n    # generating the lal_params if requested\n    lal_params: Optional[lal.Dict]\n    if mode_list is not None:\n        lal_params = get_lal_params(mode_list)\n    else:\n        lal_params = None\n\n    # checking that the transform function\n    # (used in generate_hplus_hcross)\n    # has the proper signature (if not None)\n    if transform is not None:\n        if type(transform) == \"str\":\n            transform = import_function(transform, [Polarization], Polarization)\n        else:\n            transform = cast(Callable, transform)\n            if not check_function_signature(\n                transform,\n                [Polarization],\n                Polarization,\n            ):\n                raise ValueError(\n                    f\"waveform_generator: can not use {transform} as polarization transform function, \"\n                    \"as it does not have the required signature (args: Polarization, return type: Polarization)\"\n                )\n    transform = cast(Callable[[Polarization], Polarization], transform)\n\n    # packaging all attributes into an instance of WaveformGeneratorParameters\n    # is not very elegant, but it allows to pass them as arguments\n    # to the various functions called by generate_hplus_hcross and\n    # generate_hplus_hcross_m; while avoiding circular dependency.\n    self._waveform_gen_params = WaveformGeneratorParameters(\n        approximant=approximant,\n        domain=domain,\n        f_ref=f_ref,\n        f_start=f_start,\n        spin_conversion_phase=spin_conversion_phase,\n        mode_list=mode_list,\n        lal_params=lal_params,\n        transform=transform,\n    )\n\n    # summarizing things for the user\n    _logger.info(\n        self._waveform_gen_params.to_table(\n            \"instantiated waveform generator with parameters:\"\n        )\n    )\n\n    # the argument polarization_method can be either:\n    # - None: the method used by generate_hplus_hcross will be selected based\n    #         on the approximant / domain\n    # - str: it is assumed to be the import path of a function to be imported and\n    #        used by generate_hplus_hcross\n    # - a callable: it is assumed to be the function to be used b generate_hplus_hcross\n    # The output the import_function will either be None or the function\n    # to call (imported if required)\n    self._polarization_function: Optional[PolarizationFunction] = import_function(\n        polarization_function,\n        [WaveformGeneratorParameters, WaveformParameters],\n        Polarization,\n    )\n\n    # same for generate_hplus_hcross_m\n    self._gw_polarization_method: Optional[PolarizationModesFunction] = (\n        import_function(\n            polarization_modes_function,\n            [WaveformGeneratorParameters, WaveformParameters],\n            Dict[Mode, Polarization],\n        )\n    )\n</code></pre>"},{"location":"api/waveform-generator/#dingo_waveform.waveform_generator.WaveformGenerator.generate_hplus_hcross","title":"generate_hplus_hcross","text":"<pre><code>generate_hplus_hcross(waveform_parameters: WaveformParameters) -&gt; Polarization\n</code></pre> <p>Generate h+ and h\u00d7 polarizations for a given set of waveform parameters.</p> <p>This method selects the appropriate polarization function based on: - User-provided function (if specified) - Domain type (UniformFrequencyDomain or TimeDomain) - The approximant</p> <p>It also applies any specified transform to the result (if any)</p> <p>Parameters:</p> Name Type Description Default <code>waveform_parameters</code> <code>WaveformParameters</code> <p>Parameters specific to the waveform being generated</p> required <p>Returns:</p> Type Description <code>The generated h+ and h\u00d7 polarizations</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the domain is not UniformFrequencyDomain or TimeDomain</p> Source code in <code>dingo_waveform/waveform_generator.py</code> <pre><code>def generate_hplus_hcross(\n    self, waveform_parameters: WaveformParameters\n) -&gt; Polarization:\n    \"\"\"\n    Generate h+ and h\u00d7 polarizations for a given set of waveform parameters.\n\n    This method selects the appropriate polarization function based on:\n    - User-provided function (if specified)\n    - Domain type (UniformFrequencyDomain or TimeDomain)\n    - The approximant\n\n    It also applies any specified transform to the result (if any)\n\n    Parameters\n    ----------\n    waveform_parameters :\n        Parameters specific to the waveform being generated\n\n    Returns\n    -------\n    The generated h+ and h\u00d7 polarizations\n\n    Raises\n    ------\n    ValueError\n        If the domain is not UniformFrequencyDomain or TimeDomain\n    \"\"\"\n\n    # For now only frequency and time domains are supported\n    if not isinstance(\n        self._waveform_gen_params.domain, BaseFrequencyDomain\n    ) and not isinstance(self._waveform_gen_params.domain, TimeDomain):\n        raise ValueError(\n            \"generate_hplus_hcross: domain must be an instance of UniformFrequencyDomain or TimeDomain \"\n            f\"{type(self._waveform_gen_params.domain)} not supported\"\n        )\n\n    polarization_method: PolarizationFunction\n    polarization: Polarization\n\n    if self._polarization_function is not None:\n        # we use the polarization set by the user in the constructor\n        polarization_method = self._polarization_function\n\n    # \"new\" interface\n    # SEOBNRv5PHM or SEOBNRv5HM approximant\n    if self._waveform_gen_params.approximant in (\n        Approximant(\"SEOBNRv5PHM\"),\n        Approximant(\"SEOBNRv5HM\"),\n    ):\n        polarization_method = (\n            polarization_functions.generate_FD_modes\n            if isinstance(self._waveform_gen_params.domain, BaseFrequencyDomain)\n            else polarization_functions.generate_TD_modes\n        )\n    # \"old\" interface (any other approximant)\n    else:\n        polarization_method = (\n            polarization_functions.inspiral_FD\n            if isinstance(self._waveform_gen_params.domain, BaseFrequencyDomain)\n            else polarization_functions.inspiral_TD\n        )\n\n    # logging the waveform parameters as a nice looking table\n    _logger.info(\n        waveform_parameters.to_table(\n            f\"starting to generate waveforms for approximant {self._waveform_gen_params.approximant} \"\n            f\"using function {polarization_method.__name__} \"\n            f\"and waveform parameters (f_ref={self._waveform_gen_params.f_ref}):\"\n        )\n    )\n\n    # generating the waveforms\n    polarization = polarization_method(\n        self._waveform_gen_params, waveform_parameters\n    )\n\n    # domain specific waveform transform\n    # (most domain: does nothing, MultibandedFrequencyDomain: decimate)\n    polarization = self._waveform_gen_params.domain.waveform_transform(polarization)\n\n    # transforming the waveform using the user custom function\n    # (if any)\n    if self._waveform_gen_params.transform is not None:\n        _logger.debug(\n            f\"applying transform {self._waveform_gen_params.transform} to polarization\"\n        )\n        return self._waveform_gen_params.transform(polarization)\n    else:\n        return polarization\n</code></pre>"},{"location":"api/waveform-generator/#dingo_waveform.waveform_generator.WaveformGenerator.generate_hplus_hcross_m","title":"generate_hplus_hcross_m","text":"<pre><code>generate_hplus_hcross_m(waveform_parameters: WaveformParameters) -&gt; Dict[Mode, Polarization]\n</code></pre> <p>Generate h+ and h\u00d7 polarizations for multiple modes.</p> <p>Selects the appropriate polarization modes function based on: - User-provided function (if specified) - Approximant type</p> <p>Parameters:</p> Name Type Description Default <code>waveform_parameters</code> <code>WaveformParameters</code> <p>Parameters specific to the waveform being generated</p> required <p>Returns:</p> Type Description <code>Dictionary mapping each mode (ell, m) to its corresponding</code> <code>h+ and h\u00d7 polarizations</code> Source code in <code>dingo_waveform/waveform_generator.py</code> <pre><code>def generate_hplus_hcross_m(\n    self, waveform_parameters: WaveformParameters\n) -&gt; Dict[Mode, Polarization]:\n    \"\"\"\n    Generate h+ and h\u00d7 polarizations for multiple modes.\n\n    Selects the appropriate polarization modes function based on:\n    - User-provided function (if specified)\n    - Approximant type\n\n    Parameters\n    ----------\n    waveform_parameters :\n        Parameters specific to the waveform being generated\n\n    Returns\n    -------\n    Dictionary mapping each mode (ell, m) to its corresponding\n    h+ and h\u00d7 polarizations\n    \"\"\"\n\n    # checking the configuration is suitable for calling generate_hplus_hcross_m.\n    # A ValueError will be raised if not.\n    # In a separate method for readability only.\n    self._generate_hplus_hcross_m_checks(waveform_parameters)\n\n    # getting the generator function.\n    polarization_modes_function: PolarizationModesFunction\n    if self._gw_polarization_method is not None:\n        # we use the method provided by the user in the constructor\n        polarization_modes_function = self._gw_polarization_method\n    else:\n        # we infer from the approximant\n        # (code in a separate function for readability only)\n        polarization_modes_function = self._get_polarization_modes_function(\n            self._waveform_gen_params.approximant\n        )\n\n    # printing in the log the waveform parameters\n    _logger.info(\n        waveform_parameters.to_table(\n            f\"starting to generate waveforms (separated by modes) \"\n            f\"for approximant {self._waveform_gen_params.approximant} \"\n            f\"using {polarization_modes_function.__name__} \"\n            f\"with waveform parameters (f_ref={self._waveform_gen_params.f_ref}):\"\n        )\n    )\n\n    # generating the waveforms\n    polarization_modes: Dict[Mode, Polarization] = polarization_modes_function(\n        self._waveform_gen_params, waveform_parameters\n    )\n\n    # logging the generated polarizations as a nice looking table.\n    _logger.debug(\n        f\"generated polarizations:\\n{polarizations_to_table(polarization_modes)}\"\n    )\n\n    return polarization_modes\n</code></pre>"},{"location":"api/waveform-generator/#waveformparameters","title":"WaveformParameters","text":""},{"location":"api/waveform-generator/#dingo_waveform.waveform_parameters.WaveformParameters","title":"WaveformParameters  <code>dataclass</code>","text":"<pre><code>WaveformParameters(luminosity_distance: Optional[float] = None, redshift: Optional[float] = None, comoving_distance: Optional[float] = None, chi_1: Optional[float] = None, chi_2: Optional[float] = None, chi_1_in_plane: Optional[float] = None, chi_2_in_plane: Optional[float] = None, a_1: Optional[float] = None, a_2: Optional[float] = None, phi_jl: Optional[float] = None, phi_12: Optional[float] = None, tilt_1: Optional[float] = None, tilt_2: Optional[float] = None, dec: Optional[float] = None, ra: Optional[float] = None, geocent_time: Optional[float] = None, delta_phase: Optional[float] = None, phase: Optional[float] = None, psi: Optional[float] = None, theta_jn: Optional[float] = None, mass_1: Optional[float] = None, mass_2: Optional[float] = None, total_mass: Optional[float] = None, chirp_mass: Optional[float] = None, mass_ratio: Optional[float] = None, symmetric_mass_ratio: Optional[float] = None, mass_1_source: Optional[float] = None, mass_2_source: Optional[float] = None, total_mass_source: Optional[float] = None, chirp_mass_source: Optional[float] = None, l_max: Optional[float] = None, postadiabatic: Optional[Any] = None, postadiabatic_type: Optional[Any] = None, lmax_nyquist: Optional[int] = None)\n</code></pre> <p>               Bases: <code>TableStr</code></p> <p>Configuration dataclass for generating waveforms.</p> <p>This class contains all parameters necessary for waveform generation, organized by physical categories. All parameters are optional and default to None.</p> <p>Parameters:</p> Name Type Description Default <code>Distance</code> required <code>luminosity_distance</code> <code>Optional[float]</code> <p>Luminosity distance to the source in Mpc</p> <code>None</code> <code>redshift</code> <code>Optional[float]</code> <p>Redshift of the source</p> <code>None</code> <code>comoving_distance</code> <code>Optional[float]</code> <p>Comoving distance to the source</p> <code>None</code> Spin Parameters <p>chi_1 :     Dimensionless spin magnitude of object 1 chi_2 :     Dimensionless spin magnitude of object 2 chi_1_in_plane :     In-plane component of spin 1 chi_2_in_plane :     In-plane component of spin 2 a_1 :     Alternative representation of spin 1 magnitude a_2 :     Alternative representation of spin 2 magnitude</p> Angular Parameters <p>phi_jl :     Angle between total angular momentum and line of sight phi_12 :     Angle between spins tilt_1 :     Tilt angle of spin 1 tilt_2 :     Tilt angle of spin 2 dec :     Declination angle (in radians) ra :     Right ascension angle (in radians) geocent_time :     Geocentric time (in seconds) delta_phase :     Phase difference between h+ and h\u00d7 polarizations phase :     Orbital phase at reference frequency psi :     Polarization angle theta_jn :     Angle between total angular momentum and line of sight</p> Mass Parameters <p>mass_1 :     Mass of object 1 (in solar masses) mass_2 :     Mass of object 2 (in solar masses) total_mass :     Total mass of the system chirp_mass :     Chirp mass of the system mass_ratio :     Mass ratio q = m1/m2 symmetric_mass_ratio :     Symmetric mass ratio \u03b7 = m1*m2/(m1+m2)\u00b2</p> Source Frame Mass Parameters <p>mass_1_source :     Source frame mass of object 1 mass_2_source :     Source frame mass of object 2 total_mass_source :     Source frame total mass chirp_mass_source :     Source frame chirp mass l_max :     Maximum harmonic order to include</p> SEOBNRv5 Specific Parameters <p>postadiabatic :     Post-adiabatic correction parameters for SEOBNRv5 postadiabatic_type :     Type specification for post-adiabatic corrections lmax_nyquist :     Maximum harmonic index for Nyquist sampling</p>"},{"location":"api/waveform-generator/#helper-functions","title":"Helper Functions","text":""},{"location":"api/waveform-generator/#build_waveform_generator","title":"build_waveform_generator","text":""},{"location":"api/waveform-generator/#dingo_waveform.waveform_generator.build_waveform_generator","title":"build_waveform_generator","text":"<pre><code>build_waveform_generator(file_path: Path) -&gt; WaveformGenerator\n</code></pre> Source code in <code>dingo_waveform/waveform_generator.py</code> <pre><code>@dispatch(str)\ndef build_waveform_generator(file_path: Path) -&gt; WaveformGenerator:\n    return build_waveform_generator(Path(file_path))\n</code></pre>"},{"location":"api/waveform-generator/#usage-examples","title":"Usage Examples","text":""},{"location":"api/waveform-generator/#basic-generation","title":"Basic Generation","text":"<pre><code>from dingo_waveform import (\n    WaveformGenerator,\n    WaveformParameters,\n    Approximant,\n    UniformFrequencyDomain\n)\n\n# Create domain\ndomain = UniformFrequencyDomain(\n    f_min=20.0,\n    f_max=1024.0,\n    delta_f=0.125\n)\n\n# Create generator\nwfg = WaveformGenerator(\n    approximant=Approximant(\"IMRPhenomXPHM\"),\n    domain=domain,\n    f_ref=20.0\n)\n\n# Set parameters\nparams = WaveformParameters(\n    mass_1=36.0,\n    mass_2=29.0,\n    luminosity_distance=1000.0,\n    theta_jn=0.5,\n    phase=0.0,\n    a_1=0.3,\n    a_2=0.2,\n    tilt_1=0.5,\n    tilt_2=0.8,\n    phi_12=1.7,\n    phi_jl=0.3,\n    geocent_time=0.0\n)\n\n# Generate\npol = wfg.generate_hplus_hcross(params)\n</code></pre>"},{"location":"api/waveform-generator/#mode-separated-generation","title":"Mode-Separated Generation","text":"<pre><code># Using same generator and params from above\nmodes = wfg.generate_hplus_hcross_m(params)\n\nfor m, pol in modes.items():\n    print(f\"Mode m={m}: amplitude = {abs(pol.h_plus[0]):.2e}\")\n</code></pre>"},{"location":"api/waveform-generator/#building-from-dictionary","title":"Building from Dictionary","text":"<pre><code>config = {\n    \"domain\": {\n        \"type\": \"UniformFrequencyDomain\",\n        \"f_min\": 20.0,\n        \"f_max\": 1024.0,\n        \"delta_f\": 0.125\n    },\n    \"waveform_generator\": {\n        \"approximant\": \"IMRPhenomXPHM\",\n        \"f_ref\": 20.0\n    }\n}\n\nwfg = build_waveform_generator(config)\n</code></pre>"},{"location":"api/waveform-generator/#see-also","title":"See Also","text":"<ul> <li>Domains API - Domain definitions</li> <li>Approximants API - Waveform approximants</li> <li>Polarizations API - Polarization outputs</li> </ul>"},{"location":"cli/dingo-generate-dataset/","title":"dingo_generate_dataset","text":""},{"location":"cli/dingo-plot/","title":"dingo-plot","text":"<p>Generate and visualize waveforms from JSON configuration files.</p>"},{"location":"cli/dingo-plot/#usage","title":"Usage","text":"<pre><code>dingo-plot [OPTIONS]\n</code></pre>"},{"location":"cli/dingo-plot/#options","title":"Options","text":"Option Short Description Default <code>--config</code> <code>-c</code> Path to JSON configuration file <code>config.json</code> <code>--modes</code> <code>-m</code> Plot mode-separated waveforms False <code>--output</code> <code>-o</code> Output directory for HTML files <code>.</code> (current directory) <code>--show</code> <code>-s</code> Display plots in browser False"},{"location":"cli/dingo-plot/#examples","title":"Examples","text":""},{"location":"cli/dingo-plot/#basic-usage","title":"Basic Usage","text":"<p>Generate plots for basic polarizations using <code>config.json</code> in current directory:</p> <pre><code>dingo-plot\n</code></pre>"},{"location":"cli/dingo-plot/#specify-configuration-file","title":"Specify Configuration File","text":"<pre><code>dingo-plot --config /path/to/my_config.json\n</code></pre>"},{"location":"cli/dingo-plot/#plot-mode-separated-waveforms","title":"Plot Mode-Separated Waveforms","text":"<pre><code>dingo-plot --modes\n</code></pre>"},{"location":"cli/dingo-plot/#save-to-custom-directory","title":"Save to Custom Directory","text":"<pre><code>dingo-plot --output plots/\n</code></pre>"},{"location":"cli/dingo-plot/#display-in-browser","title":"Display in Browser","text":"<pre><code>dingo-plot --show\n</code></pre>"},{"location":"cli/dingo-plot/#combine-options","title":"Combine Options","text":"<pre><code>dingo-plot --config my_config.json --modes --output results/ --show\n</code></pre>"},{"location":"cli/dingo-plot/#configuration-file-format","title":"Configuration File Format","text":"<p>The configuration file uses the same format as <code>dingo-verify</code>:</p> <pre><code>{\n  \"domain\": {\n    \"type\": \"UniformFrequencyDomain\",\n    \"f_min\": 20.0,\n    \"f_max\": 1024.0,\n    \"delta_f\": 0.125\n  },\n  \"waveform_generator\": {\n    \"approximant\": \"IMRPhenomXPHM\",\n    \"f_ref\": 20.0,\n    \"f_start\": 20.0\n  },\n  \"waveform_parameters\": {\n    \"mass_1\": 36.0,\n    \"mass_2\": 29.0,\n    \"luminosity_distance\": 1000.0,\n    \"theta_jn\": 0.5,\n    \"phase\": 0.0,\n    \"a_1\": 0.3,\n    \"a_2\": 0.2,\n    \"tilt_1\": 0.5,\n    \"tilt_2\": 0.8,\n    \"phi_12\": 1.7,\n    \"phi_jl\": 0.3,\n    \"geocent_time\": 0.0\n  }\n}\n</code></pre>"},{"location":"cli/dingo-plot/#domain-types","title":"Domain Types","text":"<p>Supported domain types:</p> <ul> <li><code>UniformFrequencyDomain</code> - Standard frequency domain</li> <li><code>MultibandedFrequencyDomain</code> - Adaptive frequency binning</li> <li><code>TimeDomain</code> - Time domain</li> </ul> <p>See Domains for details.</p>"},{"location":"cli/dingo-plot/#generated-plots","title":"Generated Plots","text":""},{"location":"cli/dingo-plot/#basic-polarizations-without-modes","title":"Basic Polarizations (without <code>--modes</code>)","text":"<p>When plotting basic polarizations, the following HTML files are generated:</p>"},{"location":"cli/dingo-plot/#frequency-domain","title":"Frequency Domain","text":"<ul> <li><code>polarizations_amplitude.html</code> - Amplitude plot for h\u208a and h\u00d7</li> <li><code>polarizations_both.html</code> - Combined amplitude and phase plots</li> </ul>"},{"location":"cli/dingo-plot/#time-domain","title":"Time Domain","text":"<ul> <li><code>polarizations_time.html</code> - Time-domain waveforms</li> <li><code>spectrogram.html</code> - Spectrogram visualization</li> <li><code>qtransform.html</code> - Q-transform visualization</li> </ul>"},{"location":"cli/dingo-plot/#mode-separated-waveforms-with-modes","title":"Mode-Separated Waveforms (with <code>--modes</code>)","text":"<p>When using the <code>--modes</code> flag, these files are generated:</p> <ul> <li><code>mode_amplitudes.html</code> - Bar chart comparing mode amplitudes</li> <li><code>individual_modes.html</code> - All modes overlaid on single plot</li> <li><code>mode_comparison.html</code> - Modes compared to dominant mode</li> <li><code>modes_grid.html</code> - Grid layout showing each mode separately</li> </ul>"},{"location":"cli/dingo-plot/#interactive-features","title":"Interactive Features","text":"<p>All generated plots are interactive Plotly visualizations with:</p> <ul> <li>Zoom: Click and drag to zoom</li> <li>Pan: Shift + drag to pan</li> <li>Hover: Hover for data values</li> <li>Legend: Click to toggle traces</li> <li>Export: Download as PNG (requires browser)</li> </ul>"},{"location":"cli/dingo-plot/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/dingo-plot/#configuration-errors","title":"Configuration Errors","text":"<pre><code>\u274c Configuration Error: domain.type is required\n</code></pre> <p>Ensure your JSON file has all required fields. See configuration format above.</p>"},{"location":"cli/dingo-plot/#mode-generation-errors","title":"Mode Generation Errors","text":"<pre><code>\u274c Configuration Error: Reference mode (2, 2) not found\n</code></pre> <p>The selected approximant may not support mode-separated waveforms. Use approximants like: - IMRPhenomXPHM - SEOBNRv5PHM - SEOBNRv5HM - SEOBNRv4PHM</p>"},{"location":"cli/dingo-plot/#file-not-found","title":"File Not Found","text":"<pre><code>\u274c Error: Configuration file not found: config.json\n</code></pre> <p>Either create a <code>config.json</code> in the current directory or specify the path with <code>--config</code>.</p>"},{"location":"cli/dingo-plot/#see-also","title":"See Also","text":"<ul> <li>dingo-verify - Verify waveform correctness</li> <li>dingo_generate_dataset - Generate waveform datasets</li> <li>Plotting API - Programmatic plotting interface</li> </ul>"},{"location":"cli/dingo-verify/","title":"dingo-verify","text":""},{"location":"concepts/approximants/","title":"Approximants","text":""},{"location":"concepts/domains/","title":"Domains","text":"<p>Domains define how gravitational waveforms are sampled in either frequency or time.</p>"},{"location":"concepts/domains/#why-domains-matter","title":"Why Domains Matter","text":"<p>The choice of domain affects:</p> <ul> <li>Memory usage - How much data is stored</li> <li>Computational efficiency - How fast waveforms are generated</li> <li>Neural network training - Dimensionality of input data</li> </ul>"},{"location":"concepts/domains/#domain-types","title":"Domain Types","text":""},{"location":"concepts/domains/#uniformfrequencydomain","title":"UniformFrequencyDomain","text":"<p>Standard uniform frequency sampling with constant spacing \u0394f.</p> <p>When to use: - Standard parameter estimation - Matched filtering - General-purpose waveform generation</p> <p>Parameters: - <code>f_min</code> - Minimum frequency (Hz) - <code>f_max</code> - Maximum frequency (Hz) - <code>delta_f</code> - Frequency spacing (Hz)</p>"},{"location":"concepts/domains/#multibandedfrequencydomain","title":"MultibandedFrequencyDomain","text":"<p>Adaptive frequency binning that reduces dimensionality while preserving waveform information.</p> <p>When to use: - Neural network training - Large-scale inference - Memory-constrained applications</p> <p>Parameters: - <code>f_min</code>, <code>f_max</code> - Frequency range - <code>delta_f_initial</code> - Initial frequency spacing - <code>n_bins_per_harmonic</code> - Bins per harmonic band</p>"},{"location":"concepts/domains/#timedomain","title":"TimeDomain","text":"<p>Time-domain sampling for waveforms.</p> <p>When to use: - Time-domain approximants - Whitening operations - Time-frequency analysis</p> <p>Parameters: - <code>duration</code> - Total duration (seconds) - <code>delta_t</code> - Time step (seconds)</p>"},{"location":"concepts/domains/#see-also","title":"See Also","text":"<ul> <li>API Reference: Domains</li> <li>Quick Start</li> </ul>"},{"location":"concepts/modes/","title":"Modes","text":""},{"location":"concepts/overview/","title":"Core Concepts","text":""},{"location":"concepts/overview/#overview","title":"Overview","text":"<p>dingo-waveform is built around several key concepts that work together to generate gravitational wave waveforms efficiently.</p>"},{"location":"concepts/overview/#the-waveform-generation-pipeline","title":"The Waveform Generation Pipeline","text":"<pre><code>Domain \u2192 Approximant \u2192 WaveformParameters \u2192 WaveformGenerator \u2192 Polarizations\n</code></pre>"},{"location":"concepts/overview/#1-domain","title":"1. Domain","text":"<p>The domain defines how the waveform is sampled - either in frequency or time:</p> <ul> <li>UniformFrequencyDomain: Standard uniform frequency sampling</li> <li>MultibandedFrequencyDomain: Adaptive frequency binning for efficiency</li> <li>TimeDomain: Time-domain sampling</li> </ul> <p>Learn more about Domains \u2192</p>"},{"location":"concepts/overview/#2-approximant","title":"2. Approximant","text":"<p>The approximant is the waveform model used to compute the gravitational wave signal:</p> <ul> <li>IMRPhenomXPHM: Precessing binaries with higher modes</li> <li>SEOBNRv5PHM: Effective-one-body model with higher modes</li> <li>SEOBNRv4PHM: Previous generation model</li> </ul> <p>Learn more about Approximants \u2192</p>"},{"location":"concepts/overview/#3-waveform-parameters","title":"3. Waveform Parameters","text":"<p>WaveformParameters describe the binary system:</p> <ul> <li>Masses (m\u2081, m\u2082)</li> <li>Spins (a\u2081, a\u2082, tilt angles)</li> <li>Distance and orientation</li> <li>Orbital phase</li> </ul>"},{"location":"concepts/overview/#4-waveform-generator","title":"4. Waveform Generator","text":"<p>The WaveformGenerator combines domain, approximant, and parameters to produce waveforms using LALSimulation under the hood.</p>"},{"location":"concepts/overview/#5-polarizations","title":"5. Polarizations","text":"<p>The output Polarizations contain the two gravitational wave polarization states:</p> <ul> <li>h\u208a (h_plus): Plus polarization</li> <li>h\u00d7 (h_cross): Cross polarization</li> </ul> <p>Learn more about Polarizations \u2192</p>"},{"location":"concepts/overview/#mode-separated-waveforms","title":"Mode-Separated Waveforms","text":"<p>For higher-mode approximants, waveforms can be decomposed into spherical harmonic modes:</p> <p>\\[ h(t) = \\sum_{\\ell,m} h_{\\ell m}(t) Y_{\\ell m}(\\theta, \\phi) \\]</p> <p>In dingo-waveform, modes are represented by their m value (azimuthal quantum number).</p> <p>Learn more about Modes \u2192</p>"},{"location":"concepts/overview/#workflow-examples","title":"Workflow Examples","text":""},{"location":"concepts/overview/#basic-workflow","title":"Basic Workflow","text":"<pre><code># 1. Define domain\ndomain = UniformFrequencyDomain(f_min=20.0, f_max=1024.0, delta_f=0.125)\n\n# 2. Create generator\nwfg = WaveformGenerator(\n    approximant=Approximant(\"IMRPhenomXPHM\"),\n    domain=domain,\n    f_ref=20.0\n)\n\n# 3. Set parameters\nparams = WaveformParameters(mass_1=36.0, mass_2=29.0, ...)\n\n# 4. Generate\npolarization = wfg.generate_hplus_hcross(params)\n</code></pre>"},{"location":"concepts/overview/#mode-separated-workflow","title":"Mode-Separated Workflow","text":"<pre><code># Same setup as above, then:\nmodes = wfg.generate_hplus_hcross_m(params)\n\n# Access individual modes\nfor m, pol in modes.items():\n    print(f\"Mode m={m}\")\n</code></pre>"},{"location":"concepts/overview/#computational-considerations","title":"Computational Considerations","text":""},{"location":"concepts/overview/#cpu-vs-gpu","title":"CPU vs GPU","text":"<ul> <li>Waveform generation: CPU-only (via LALSimulation)</li> <li>Domain transformations: Can use GPU via PyTorch tensors</li> <li>Neural network inference (in main dingo package): GPU-accelerated</li> </ul>"},{"location":"concepts/overview/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use MultibandedFrequencyDomain for neural network training to reduce dimensionality</li> <li>Batch generate multiple waveforms when creating datasets</li> <li>Cache domain objects when generating many waveforms with same sampling</li> </ol>"},{"location":"concepts/overview/#next-steps","title":"Next Steps","text":"<p>Dive deeper into specific concepts:</p> <ul> <li>Domains - Understand frequency and time sampling</li> <li>Approximants - Learn about waveform models</li> <li>Polarizations - Understand waveform outputs</li> <li>Modes - Work with spherical harmonic decomposition</li> </ul>"},{"location":"concepts/polarizations/","title":"Polarizations","text":""},{"location":"examples/basic-waveform/","title":"Basic Waveform Example","text":""},{"location":"examples/dataset-generation/","title":"Dataset Generation Example","text":""},{"location":"examples/mode-separated/","title":"Mode-Separated Example","text":""},{"location":"examples/plotting/","title":"Plotting Example","text":""},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python \u2265 3.8</li> <li>LALSuite \u2265 7.15</li> <li>CUDA-capable GPU (optional, for neural network inference in main dingo package)</li> </ul>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":""},{"location":"getting-started/installation/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/dingo-gw/dingo-waveform.git\ncd dingo-waveform\n</code></pre>"},{"location":"getting-started/installation/#basic-installation","title":"Basic Installation","text":"<p>Install the package in editable mode:</p> <pre><code>pip install -e .\n</code></pre> <p>This installs dingo-waveform with all required dependencies including:</p> <ul> <li>LALSuite (waveform generation)</li> <li>NumPy, SciPy (numerical computing)</li> <li>PyTorch (for domain transformations)</li> <li>gwpy (time-frequency analysis)</li> <li>plotly (interactive visualization)</li> <li>bilby (parameter conversions and priors)</li> </ul>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For development work, install with additional tools:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre> <p>This includes:</p> <ul> <li><code>black</code> - Code formatter</li> <li><code>isort</code> - Import sorter</li> <li><code>mypy</code> - Type checker</li> <li><code>pylint</code> - Code linter</li> <li><code>pytest</code> - Testing framework</li> <li><code>marimo</code> - Interactive notebooks</li> </ul>"},{"location":"getting-started/installation/#documentation-installation","title":"Documentation Installation","text":"<p>To build documentation locally:</p> <pre><code>pip install -e \".[docs]\"\n</code></pre> <p>This includes:</p> <ul> <li><code>mkdocs</code> - Documentation generator</li> <li><code>mkdocs-material</code> - Material theme</li> <li><code>mkdocstrings</code> - API documentation from docstrings</li> </ul>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>After installation, verify that the executables are available:</p> <pre><code># Check version\npython -c \"import dingo_waveform; print(dingo_waveform.__version__)\"\n\n# Test executables\ndingo-verify --help\ndingo-plot --help\ndingo_generate_dataset --help\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#lalsuite-installation-issues","title":"LALSuite Installation Issues","text":"<p>If you encounter issues with LALSuite, consider using conda:</p> <pre><code>conda install -c conda-forge lalsuite\n</code></pre>"},{"location":"getting-started/installation/#import-errors","title":"Import Errors","text":"<p>If you see import errors, ensure all dependencies are installed:</p> <pre><code>pip install -e . --force-reinstall\n</code></pre>"},{"location":"getting-started/installation/#gpu-support","title":"GPU Support","text":"<p>While waveform generation is CPU-only, PyTorch with CUDA support may be needed for neural network components:</p> <pre><code># Install PyTorch with CUDA support (adjust version as needed)\npip install torch --index-url https://download.pytorch.org/whl/cu118\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Once installed, proceed to the Quick Start guide to generate your first waveform.</p>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will walk you through generating your first gravitational wave waveform with dingo-waveform.</p>"},{"location":"getting-started/quickstart/#basic-waveform-generation","title":"Basic Waveform Generation","text":""},{"location":"getting-started/quickstart/#1-import-required-components","title":"1. Import Required Components","text":"<pre><code>from dingo_waveform import (\n    WaveformGenerator,\n    WaveformParameters,\n    Approximant,\n    UniformFrequencyDomain\n)\n</code></pre>"},{"location":"getting-started/quickstart/#2-define-the-domain","title":"2. Define the Domain","text":"<p>The domain specifies the frequency (or time) sampling for the waveform:</p> <pre><code>domain = UniformFrequencyDomain(\n    f_min=20.0,      # Minimum frequency (Hz)\n    f_max=1024.0,    # Maximum frequency (Hz)\n    delta_f=0.125    # Frequency resolution (Hz)\n)\n</code></pre>"},{"location":"getting-started/quickstart/#3-create-a-waveform-generator","title":"3. Create a Waveform Generator","text":"<pre><code>wfg = WaveformGenerator(\n    approximant=Approximant(\"IMRPhenomXPHM\"),  # Waveform model\n    domain=domain,\n    f_ref=20.0,        # Reference frequency\n    f_start=20.0       # Starting frequency\n)\n</code></pre>"},{"location":"getting-started/quickstart/#4-set-binary-parameters","title":"4. Set Binary Parameters","text":"<pre><code>params = WaveformParameters(\n    mass_1=36.0,                    # Primary mass (solar masses)\n    mass_2=29.0,                    # Secondary mass (solar masses)\n    luminosity_distance=1000.0,     # Distance (Mpc)\n    theta_jn=0.5,                   # Inclination angle\n    phase=0.0,                      # Orbital phase\n    a_1=0.3,                        # Primary spin magnitude\n    a_2=0.2,                        # Secondary spin magnitude\n    tilt_1=0.5,                     # Primary tilt angle\n    tilt_2=0.8,                     # Secondary tilt angle\n    phi_12=1.7,                     # Azimuthal angle between spins\n    phi_jl=0.3,                     # Azimuthal angle of L\n    geocent_time=0.0                # Coalescence time\n)\n</code></pre>"},{"location":"getting-started/quickstart/#5-generate-the-waveform","title":"5. Generate the Waveform","text":"<pre><code># Generate h+ and h\u00d7 polarizations\npolarization = wfg.generate_hplus_hcross(params)\n\nprint(f\"h_plus shape: {polarization.h_plus.shape}\")\nprint(f\"h_cross shape: {polarization.h_cross.shape}\")\n</code></pre>"},{"location":"getting-started/quickstart/#visualizing-the-waveform","title":"Visualizing the Waveform","text":""},{"location":"getting-started/quickstart/#using-the-plotting-module","title":"Using the Plotting Module","text":"<pre><code>from dingo_waveform.plotting import plot_polarizations_frequency\n\n# Create interactive plot\nfig = plot_polarizations_frequency(\n    polarization,\n    domain,\n    plot_type=\"amplitude\"\n)\n\n# Display in browser\nfig.show()\n\n# Or save to file\nfig.write_html(\"waveform.html\")\n</code></pre>"},{"location":"getting-started/quickstart/#using-the-command-line-tool","title":"Using the Command-Line Tool","text":"<p>Create a configuration file <code>config.json</code>:</p> <pre><code>{\n  \"domain\": {\n    \"type\": \"UniformFrequencyDomain\",\n    \"f_min\": 20.0,\n    \"f_max\": 1024.0,\n    \"delta_f\": 0.125\n  },\n  \"waveform_generator\": {\n    \"approximant\": \"IMRPhenomXPHM\",\n    \"f_ref\": 20.0\n  },\n  \"waveform_parameters\": {\n    \"mass_1\": 36.0,\n    \"mass_2\": 29.0,\n    \"luminosity_distance\": 1000.0,\n    \"theta_jn\": 0.5,\n    \"phase\": 0.0,\n    \"a_1\": 0.3,\n    \"a_2\": 0.2,\n    \"tilt_1\": 0.5,\n    \"tilt_2\": 0.8,\n    \"phi_12\": 1.7,\n    \"phi_jl\": 0.3,\n    \"geocent_time\": 0.0\n  }\n}\n</code></pre> <p>Then run:</p> <pre><code># Generate and plot waveform\ndingo-plot --config config.json --output plots/\n</code></pre>"},{"location":"getting-started/quickstart/#mode-separated-waveforms","title":"Mode-Separated Waveforms","text":"<p>For approximants that support higher-order modes (like IMRPhenomXPHM):</p> <pre><code># Generate mode-separated polarizations\nmodes = wfg.generate_hplus_hcross_m(params)\n\nprint(f\"Number of modes: {len(modes)}\")\nprint(f\"Available modes: {sorted(modes.keys())}\")\n\n# Access individual modes\nfor m, pol in modes.items():\n    print(f\"Mode m={m}: h_plus shape = {pol.h_plus.shape}\")\n</code></pre>"},{"location":"getting-started/quickstart/#plotting-modes","title":"Plotting Modes","text":"<pre><code>from dingo_waveform.plotting import (\n    plot_mode_amplitudes,\n    plot_individual_modes\n)\n\n# Bar chart of mode amplitudes\nfig1 = plot_mode_amplitudes(modes, domain)\nfig1.show()\n\n# All modes on same plot\nfig2 = plot_individual_modes(modes, domain, domain_type=\"frequency\")\nfig2.show()\n</code></pre> <p>Or using the CLI:</p> <pre><code>dingo-plot --modes --output plots/\n</code></pre>"},{"location":"getting-started/quickstart/#time-domain-waveforms","title":"Time Domain Waveforms","text":"<p>To generate time-domain waveforms:</p> <pre><code>from dingo_waveform import TimeDomain\n\n# Define time domain\ntime_domain = TimeDomain(\n    duration=8.0,     # Total duration (seconds)\n    delta_t=1/2048.0  # Time step (seconds)\n)\n\n# Create generator with time domain\nwfg_td = WaveformGenerator(\n    approximant=Approximant(\"SEOBNRv5PHM\"),\n    domain=time_domain,\n    f_ref=20.0\n)\n\n# Generate\npolarization_td = wfg_td.generate_hplus_hcross(params)\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Domains for different frequency sampling strategies</li> <li>Explore Approximants to understand different waveform models</li> <li>Check Examples for more detailed tutorials</li> <li>Read the API Reference for complete documentation</li> </ul>"}]}