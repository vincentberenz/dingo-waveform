"""
This module does not contain proper unit tests.
It compares waveforms generated by this package (dingo-waveform) with waveforms generated by the original
Dingo packages.
Waveform generation was run using the Dingo packages, and some data structure dumped into pickle files.
These files are located in tests/ground_truth. The tests unpickle them, and compare with the data structures
obtained via this package.
Tests passing mean the waveform are correct, to the extend waveform generated by the dingo package can be considered
ground truth.

TODO: more tests should be performed. Here, only the waveform as generated by running
      dingo.gw.waveform_generator.waveform_generator.py is checked (section __name__ == '__main__')
      see: https://github.com/dingo-gw/dingo/blob/d78eaadb90e720f32963939787a72fc538c508c0/dingo/gw/waveform_generator/waveform_generator.py#L1374
"""

import pickle
from dataclasses import astuple
from pathlib import Path
from typing import Any, Dict, cast

import numpy as np
from lal import COMPLEX16FrequencySeries
from lalsimulation import SimInspiralChooseFDModes, SphHarmFrequencySeries

from dingo_waveform.approximant import Approximant
from dingo_waveform.domains import FrequencyDomain
from dingo_waveform.polarization_modes_functions import (
    inspiral_choose_FD_modes,
    polarization_modes_utils,
)
from dingo_waveform.polarizations import Polarization, sum_contributions_m
from dingo_waveform.types import FrequencySeries, Mode, Modes
from dingo_waveform.waveform_generator import WaveformGenerator
from dingo_waveform.waveform_generator_parameters import WaveformGeneratorParameters
from dingo_waveform.waveform_parameters import WaveformParameters


def _restore_ground_truth(name: str) -> Any:
    # unpickle ground truth file located in tests/ground_truths.
    # name should be the file name.
    pickled_path = Path(__file__).parent / "ground_truths" / name
    with open(pickled_path, "rb") as f:
        return pickle.load(f)


def _same(a: np.ndarray, b: np.ndarray, tolerance=1e-25) -> None:
    # assert a and b are the same up to the tolerance.
    # 'same': same shape, dtype and values.
    assert a.shape == b.shape
    assert a.dtype == b.dtype
    assert np.allclose(a, b, atol=tolerance)


def _compare_frequency_series(
    series1: COMPLEX16FrequencySeries,
    series2: COMPLEX16FrequencySeries,
    tolerance=1e-25,
):
    # assert the series are the 'same':
    # same gpsSeconds, f0, deltaF and data (see _same).
    assert abs(series1.epoch.gpsSeconds - series2.epoch.gpsSeconds) <= tolerance
    assert abs(series1.f0 - series2.f0) <= tolerance
    assert abs(series1.deltaF - series2.deltaF) <= tolerance
    _same(series1.data.data, series2.data.data, tolerance=tolerance)


def _same_frequency_series_dict(
    a: Dict[Modes, COMPLEX16FrequencySeries], b: Dict[Modes, COMPLEX16FrequencySeries]
) -> None:
    # assert a and b have the same modes, and that the corresponding series
    # are the same (see _compare_frequency_series)
    assert set(a.keys()) == set(b.keys())
    for mode in a.keys():
        _compare_frequency_series(a[mode], b[mode])


def _same_dict(a: Dict[Modes, np.ndarray], b: Dict[Modes, np.ndarray]) -> None:
    # assert a and b have the same modes, and that the corresponding data
    # (see _same)
    assert set(a.keys()) == set(b.keys())
    for mode in a.keys():
        _same(a[mode], b[mode])


def test_IMRPhenomXPHM_approximant() -> None:

    # Compare the waveforms generated by generate_hplus_hcross_m and
    # generate_hplus_hcross for IMRPhenomXPHM

    # reading the ground truth (i.e. waveform obtained on the original dingo package)
    ground_truth = _restore_ground_truth("fd_IMRPhenomXPHM.pickled")
    pol_m_ground_truth = cast(
        Dict[int, Dict[str, FrequencySeries]],
        ground_truth["pol_m"],
    )
    phase_shift = cast(float, ground_truth["phase_shift"])
    pol_ground_truth = cast(Dict[str, FrequencySeries], ground_truth["pol"])
    pol_ref_ground_truth = ground_truth["pol_ref"]

    # waveform generation configuration

    # domain settings (type: FrequencyDomain)
    f_min = 10.0
    f_max = 2048.0
    delta_f = 0.125

    p = {
        "mass_ratio": 0.3501852584069329,
        "chirp_mass": 31.709276525188667,
        "luminosity_distance": 1000.0,
        "theta_jn": 1.3663250108421872,
        "phase": 2.3133395191342094,
        "a_1": 0.9082488389607664,
        "a_2": 0.23195443013657285,
        "tilt_1": 2.2991912365076708,
        "tilt_2": 2.2878677821511086,
        "phi_12": 2.3726027637572384,
        "phi_jl": 1.5356479043406908,
        "geocent_time": 0.0,
    }
    approximant = Approximant("IMRPhenomXPHM")
    f_ref = 20.0
    f_start = 10.0
    spin_conversion_phase = 0.0
    domain = FrequencyDomain(
        delta_f=delta_f,
        f_min=f_min,
        f_max=f_max,
    )
    waveform_parameters = WaveformParameters(**p)

    # instantiating the waveform generator
    wfg = WaveformGenerator(
        approximant, domain, f_ref, f_start, spin_conversion_phase=spin_conversion_phase
    )

    # computing the waveform
    pol_m: Dict[Mode, Polarization] = wfg.generate_hplus_hcross_m(waveform_parameters)
    pol: Polarization = sum_contributions_m(pol_m, phase_shift)
    # type ignore: we know phase is not None
    waveform_parameters.phase += phase_shift  # type: ignore
    pol_ref = wfg.generate_hplus_hcross(waveform_parameters)

    # comparing with the ground truth.

    # checking pol_m
    assert len(pol_m) == len(pol_m_ground_truth)
    assert set(pol_m.keys()) == set(pol_m_ground_truth.keys())
    for mode in pol_m.keys():
        _same(pol_m[mode].h_cross, pol_m_ground_truth[mode]["h_cross"])
        _same(pol_m[mode].h_plus, pol_m_ground_truth[mode]["h_plus"])

    # checking pol
    _same(pol.h_cross, pol_ground_truth["h_cross"])
    _same(pol.h_plus, pol_ground_truth["h_plus"])
    _same(pol.h_cross.real, pol_ground_truth["h_cross"].real)
    _same(pol.h_plus.real, pol_ground_truth["h_plus"].real)

    # checking pol_ref
    _same(pol_ref.h_cross, pol_ref_ground_truth["h_cross"])
    _same(pol_ref.h_plus, pol_ref_ground_truth["h_plus"])
