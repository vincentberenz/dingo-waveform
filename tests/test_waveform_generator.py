import pickle
from pathlib import Path
from typing import Any, Dict, Optional, cast

import numpy as np

from dingo_waveform.domains import FrequencyDomain
from dingo_waveform.polarizations import Polarization, sum_contributions_m
from dingo_waveform.types import FrequencySeries
from dingo_waveform.waveform_generator import WaveformGenerator
from dingo_waveform.waveform_parameters import WaveformParameters


def _restore_ground_truth(name: str) -> Any:
    pickled_path = Path(__file__).parent / "ground_truths" / name
    with open(pickled_path, "rb") as f:
        return pickle.load(f)


def test_IMRPhenomXPHM_approximant() -> None:

    # this has been generated by executing dingo/gw/waveform_generator/waveform_generator.py
    ground_truth = _restore_ground_truth("fd_IMRPhenomXPHM.pickled")
    pol_m_ground_truth = cast(
        Dict[int, Dict[str, FrequencySeries]],
        ground_truth["pol_m"],
    )
    phase_shift = cast(float, ground_truth["phase_shift"])
    pol_ground_truth = cast(Dict[str, FrequencySeries], ground_truth["pol"])
    pol_ref_ground_truth = ground_truth["pol_ref"]

    # domain settings (type: FrequencyDomain)
    f_min = 10.0
    f_max = 2048.0
    delta_f = 0.125

    p = {
        "mass_ratio": 0.3501852584069329,
        "chirp_mass": 31.709276525188667,
        "luminosity_distance": 1000.0,
        "theta_jn": 1.3663250108421872,
        "phase": 2.3133395191342094,
        "a_1": 0.9082488389607664,
        "a_2": 0.23195443013657285,
        "tilt_1": 2.2991912365076708,
        "tilt_2": 2.2878677821511086,
        "phi_12": 2.3726027637572384,
        "phi_jl": 1.5356479043406908,
        "geocent_time": 0.0,
    }

    approximant = "IMRPhenomXPHM"
    f_ref = 20.0
    f_start = 10.0
    spin_conversion_phase = 0.0

    domain = FrequencyDomain(
        delta_f=delta_f,
        f_min=f_min,
        f_max=f_max,
    )

    parameters = WaveformParameters(**p)

    wfg = WaveformGenerator(
        approximant, domain, f_ref, f_start, spin_conversion_phase=spin_conversion_phase
    )

    pol_m: Dict[int, Polarization] = wfg.generate_hplus_hcross_m(parameters)

    # checking our result is the same as the ground truth
    assert len(pol_m) == len(pol_m_ground_truth)
    assert set(pol_m.keys()) == set(pol_m_ground_truth.keys())
    for mode in pol_m.keys():
        assert pol_m[mode].h_cross.shape == pol_m_ground_truth[mode]["h_cross"].shape
        assert pol_m[mode].h_plus.shape == pol_m_ground_truth[mode]["h_plus"].shape
        assert pol_m[mode].h_cross.dtype == pol_m_ground_truth[mode]["h_cross"].dtype
        assert pol_m[mode].h_plus.dtype == pol_m_ground_truth[mode]["h_plus"].dtype
        assert np.allclose(pol_m[mode].h_cross, pol_m_ground_truth[mode]["h_cross"])
        assert np.allclose(pol_m[mode].h_plus, pol_m_ground_truth[mode]["h_plus"])

    pol: Polarization = sum_contributions_m(pol_m, phase_shift)
    assert pol.h_cross.dtype == pol_ground_truth["h_cross"].dtype
    assert pol.h_plus.dtype == pol_ground_truth["h_plus"].dtype
    assert pol.h_cross.shape == pol_ground_truth["h_cross"].shape
    assert pol.h_plus.shape == pol_ground_truth["h_plus"].shape
    assert np.allclose(pol.h_cross, pol_ground_truth["h_cross"])
    assert np.allclose(pol.h_plus, pol_ground_truth["h_plus"])
