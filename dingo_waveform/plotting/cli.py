#!/usr/bin/env python3
"""
Command-line interface for plotting waveforms generated by dingo-waveform.

This tool generates waveforms from a JSON configuration file and creates
interactive plots for visualization and diagnostics.
"""
import argparse
import json
import logging
import sys
from pathlib import Path
from typing import Dict, Any, Optional

from ..domains import TimeDomain, UniformFrequencyDomain, MultibandedFrequencyDomain
from ..waveform_generator import build_waveform_generator
from ..waveform_parameters import WaveformParameters
from ..logs import set_logging
from . import (
    plot_polarizations_time,
    plot_polarizations_frequency,
    plot_polarization_spectrogram,
    plot_polarization_qtransform,
    plot_mode_amplitudes,
    plot_individual_modes,
    plot_mode_comparison,
    plot_modes_grid,
)


def load_config(config_path: str) -> Dict[str, Any]:
    """
    Load configuration from JSON file.

    Parameters
    ----------
    config_path : str
        Path to JSON configuration file

    Returns
    -------
    dict
        Configuration dictionary
    """
    path = Path(config_path)
    if not path.exists():
        raise FileNotFoundError(f"Configuration file not found: {config_path}")

    with open(path, 'r') as f:
        config = json.load(f)

    return config


def validate_config(config: Dict[str, Any]) -> None:
    """
    Validate configuration has required fields.

    Parameters
    ----------
    config : dict
        Configuration dictionary

    Raises
    ------
    ValueError
        If configuration is missing required fields
    """
    required_fields = ['domain', 'waveform_generator', 'waveform_parameters']
    missing = [f for f in required_fields if f not in config]

    if missing:
        raise ValueError(
            f"Configuration missing required fields: {', '.join(missing)}\n"
            f"Required fields: {', '.join(required_fields)}"
        )

    # Validate domain
    if 'type' not in config['domain']:
        raise ValueError("domain.type is required")

    # Validate waveform_generator
    if 'approximant' not in config['waveform_generator']:
        raise ValueError("waveform_generator.approximant is required")

    # Validate waveform_parameters
    if not isinstance(config['waveform_parameters'], dict):
        raise ValueError("waveform_parameters must be a dictionary")


def create_waveform_parameters(params_config: Dict[str, Any]) -> WaveformParameters:
    """
    Create WaveformParameters from configuration.

    Parameters
    ----------
    params_config : dict
        Waveform parameters configuration

    Returns
    -------
    WaveformParameters
        Waveform parameters object
    """
    return WaveformParameters(**params_config)


def save_or_show_plot(fig, filename: Optional[str], show: bool):
    """
    Save plot to file and/or display it.

    Parameters
    ----------
    fig : plotly.graph_objects.Figure
        Plotly figure to save/show
    filename : str or None
        If provided, save to this filename
    show : bool
        If True, display the plot in browser
    """
    if filename:
        fig.write_html(filename)
        print(f"  ✓ Saved to {filename}")

    if show:
        fig.show()


def plot_basic_polarizations(
    wfg,
    params: WaveformParameters,
    domain,
    output_dir: Path,
    show: bool,
    logger: logging.Logger
):
    """
    Generate and plot basic polarizations (from generate_hplus_hcross).

    Parameters
    ----------
    wfg : WaveformGenerator
        Waveform generator
    params : WaveformParameters
        Waveform parameters
    domain : Domain
        Domain object
    output_dir : Path
        Output directory for plots
    show : bool
        Whether to display plots
    logger : logging.Logger
        Logger instance
    """
    logger.info("Generating basic polarizations...")
    pol = wfg.generate_hplus_hcross(params)
    logger.info(f"  h_plus shape: {pol.h_plus.shape}")
    logger.info(f"  h_cross shape: {pol.h_cross.shape}")

    # Determine domain type
    domain_type = None
    if isinstance(domain, TimeDomain):
        domain_type = "time"
    elif isinstance(domain, (UniformFrequencyDomain, MultibandedFrequencyDomain)):
        domain_type = "frequency"

    logger.info("Creating polarization plots...")

    # Time domain plots
    if domain_type == "time":
        fig1 = plot_polarizations_time(pol, domain)
        save_or_show_plot(fig1, output_dir / "polarizations_time.html", show)

        logger.info("  Creating spectrogram...")
        fig2 = plot_polarization_spectrogram(pol, domain)
        save_or_show_plot(fig2, output_dir / "spectrogram.html", show)

        logger.info("  Creating Q-transform...")
        fig3 = plot_polarization_qtransform(pol, domain)
        save_or_show_plot(fig3, output_dir / "qtransform.html", show)

    # Frequency domain plots
    elif domain_type == "frequency":
        fig1 = plot_polarizations_frequency(pol, domain, plot_type="amplitude")
        save_or_show_plot(fig1, output_dir / "polarizations_amplitude.html", show)

        fig2 = plot_polarizations_frequency(pol, domain, plot_type="both")
        save_or_show_plot(fig2, output_dir / "polarizations_both.html", show)


def plot_mode_separated(
    wfg,
    params: WaveformParameters,
    domain,
    output_dir: Path,
    show: bool,
    logger: logging.Logger
):
    """
    Generate and plot mode-separated polarizations (from generate_hplus_hcross_m).

    Parameters
    ----------
    wfg : WaveformGenerator
        Waveform generator
    params : WaveformParameters
        Waveform parameters
    domain : Domain
        Domain object
    output_dir : Path
        Output directory for plots
    show : bool
        Whether to display plots
    logger : logging.Logger
        Logger instance
    """
    logger.info("Generating mode-separated polarizations...")
    modes = wfg.generate_hplus_hcross_m(params)
    logger.info(f"  Number of modes: {len(modes)}")
    logger.info(f"  Modes: {sorted(modes.keys())}")

    logger.info("Creating mode plots...")

    # Mode amplitude comparison
    fig1 = plot_mode_amplitudes(modes, domain)
    save_or_show_plot(fig1, output_dir / "mode_amplitudes.html", show)

    # Individual modes overlaid
    fig2 = plot_individual_modes(
        modes,
        domain,
        domain_type="time" if isinstance(domain, TimeDomain) else "frequency"
    )
    save_or_show_plot(fig2, output_dir / "individual_modes.html", show)

    # Mode comparison (side-by-side)
    if len(modes) > 1:
        # Use the mode with largest absolute m as reference (typically dominant mode)
        reference_mode = max(modes.keys(), key=abs)
        fig3 = plot_mode_comparison(modes, domain, reference_mode=reference_mode)
        save_or_show_plot(fig3, output_dir / "mode_comparison.html", show)

    # Modes grid
    if len(modes) > 2:
        fig4 = plot_modes_grid(
            modes,
            domain,
            domain_type="time" if isinstance(domain, TimeDomain) else "frequency"
        )
        save_or_show_plot(fig4, output_dir / "modes_grid.html", show)


def main():
    """Main entry point for CLI."""
    parser = argparse.ArgumentParser(
        description="Generate and plot waveforms from dingo-waveform",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Use config.json in current directory, plot basic polarizations
  dingo-plot

  # Specify config file path
  dingo-plot --config /path/to/config.json

  # Plot mode-separated waveforms
  dingo-plot --modes

  # Save plots without displaying
  dingo-plot --output plots/

  # Display plots in browser
  dingo-plot --show

  # Both save and display
  dingo-plot --output plots/ --show

Configuration File Format:
  Uses the same format as dingo-verify:
  {
    "domain": {
      "type": "UniformFrequencyDomain" or "MultibandedFrequencyDomain" or "TimeDomain",
      "delta_f": 0.125,  # for frequency domains
      "delta_t": 0.1,    # for time domain
      "f_min": 20.0,
      "f_max": 1024.0,
      "duration": 8.0    # for time domain
    },
    "waveform_generator": {
      "approximant": "IMRPhenomXPHM",
      "f_ref": 20.0,
      "f_start": 20.0
    },
    "waveform_parameters": {
      "mass_1": 36.0,
      "mass_2": 29.0,
      "luminosity_distance": 1000.0,
      ...
    }
  }
        """
    )

    parser.add_argument(
        '--config', '-c',
        default='config.json',
        help='Path to JSON configuration file (default: config.json)'
    )
    parser.add_argument(
        '--modes', '-m',
        action='store_true',
        help='Plot mode-separated waveforms (generate_hplus_hcross_m) instead of basic polarizations. Only works with PHM/HM approximants.'
    )
    parser.add_argument(
        '--output', '-o',
        default='.',
        help='Output directory for plot HTML files (default: current directory)'
    )
    parser.add_argument(
        '--show', '-s',
        action='store_true',
        help='Display plots in browser (in addition to saving them)'
    )

    args = parser.parse_args()

    # Set up logging
    set_logging()
    logger = logging.getLogger(__name__)

    try:
        # Load and validate configuration
        logger.info(f"Loading configuration from: {args.config}")
        config = load_config(args.config)
        validate_config(config)

        # Create output directory
        output_dir = Path(args.output)
        output_dir.mkdir(parents=True, exist_ok=True)

        # Create waveform generator using factory function
        logger.info("Creating waveform generator from configuration...")
        wfg = build_waveform_generator(args.config)

        # Access domain from generator
        domain = wfg._waveform_gen_params.domain
        approximant = wfg._waveform_gen_params.approximant

        logger.info(f"  Domain: {type(domain).__name__}")
        logger.info(f"  Approximant: {approximant}")

        # Create waveform parameters
        logger.info("Creating waveform parameters...")
        params = create_waveform_parameters(config['waveform_parameters'])

        # Generate and plot
        if args.modes:
            plot_mode_separated(wfg, params, domain, output_dir, args.show, logger)
        else:
            plot_basic_polarizations(wfg, params, domain, output_dir, args.show, logger)

        logger.info("=" * 80)
        logger.info("✓ Plotting complete!")
        logger.info(f"✓ Plots saved to: {output_dir.absolute()}")
        logger.info("=" * 80)

        sys.exit(0)

    except FileNotFoundError as e:
        logger.error(f"Error: {e}")
        sys.exit(1)
    except ValueError as e:
        logger.error(f"Configuration Error: {e}")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Unexpected Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
