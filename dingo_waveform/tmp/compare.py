"""
tmp module for comparing waveforms generated by this package and waveforms
generated by the original dingo-gw package
"""

import argparse
import contextlib
import json
import logging
import os
import tempfile
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
from dingo.gw.domains import build_domain as original_build_domain
from dingo.gw.prior import (
    build_prior_with_defaults as original_build_prior_with_defaults,
)
from dingo.gw.waveform_generator import (
    NewInterfaceWaveformGenerator as NewInterfaceOriginalWaveformGenerator,
)
from dingo.gw.waveform_generator import WaveformGenerator as OriginalWaveformGenerator

from dingo_waveform.approximant import Approximant
from dingo_waveform.logs import set_logging
from dingo_waveform.polarizations import Polarization
from dingo_waveform.prior import IntrinsicPriors
from dingo_waveform.types import Mode
from dingo_waveform.waveform_generator import (
    WaveformGenerator,
    build_waveform_generator,
    polarization_modes_approximants,
)
from dingo_waveform.waveform_parameters import WaveformParameters

_approximants = (
    Approximant("IMRPhenomPv2"),
    Approximant("IMRPhenomXPHM"),
    Approximant("SEOBNRv4PHM"),
    Approximant("SEOBNRv5PHM"),
    Approximant("SEOBNRv5HM"),
)
_new_interface_approximants = (Approximant("SEOBNRv5HM"), Approximant("SEOBNRv5PHM"))
_f_start = (None, 15.0)


def _same(a: np.ndarray, b: np.ndarray, tolerance=1e-25) -> None:
    # Check if a and b are the same up to the tolerance.
    # 'same': same shape, dtype and values.
    if a.shape != b.shape:
        raise ValueError(f"Shapes do not match: {a.shape} != {b.shape}")
    if a.dtype != b.dtype:
        raise ValueError(f"Data types do not match: {a.dtype} != {b.dtype}")
    if not np.allclose(a, b, atol=tolerance):
        raise ValueError("Arrays are not close enough within the given tolerance.")


def _same_modes_pols(a: Optional[Dict], b: Optional[Dict[Mode, Polarization]]) -> None:
    if a is None or b is None:
        return
    if set(a.keys()) != set(b.keys()):
        raise ValueError("Keys of the dictionaries do not match.")
    for mode in a.keys():
        _same(a[mode]["h_plus"], b[mode].h_plus)
        _same(a[mode]["h_cross"], b[mode].h_cross)


@contextlib.contextmanager
def config_file_json(config_dict):
    """Create a temporary JSON config file and ensure its deletion."""
    tmp_dir = tempfile.mkdtemp()
    try:
        file_path = os.path.join(tmp_dir, "config.json")
        with open(file_path, "w") as f:
            json.dump(config_dict, f)
        yield file_path
    finally:
        os.remove(file_path)
        os.rmdir(tmp_dir)


_prior_PHM = {
    "mass_1": "bilby.core.prior.Constraint(minimum=10.0, maximum=80.0)",
    "mass_2": "bilby.core.prior.Constraint(minimum=10.0, maximum=80.0)",
    "mass_ratio": "bilby.gw.prior.UniformInComponentsMassRatio(minimum=0.125, maximum=1.0)",
    "chirp_mass": "bilby.gw.prior.UniformInComponentsChirpMass(minimum=25.0, maximum=100.0)",
    "luminosity_distance": 1000.0,
    "theta_jn": "bilby.core.prior.Sine(minimum=0.0, maximum=np.pi)",
    "phase": 'bilby.core.prior.Uniform(minimum=0.0, maximum=2*np.pi, boundary="periodic")',
    "a_1": "bilby.core.prior.Uniform(minimum=0.0, maximum=0.99)",
    "a_2": "bilby.core.prior.Uniform(minimum=0.0, maximum=0.99)",
    "tilt_1": "bilby.core.prior.Sine(minimum=0.0, maximum=np.pi)",
    "tilt_2": "bilby.core.prior.Sine(minimum=0.0, maximum=np.pi)",
    "phi_12": 'bilby.core.prior.Uniform(minimum=0.0, maximum=2*np.pi, boundary="periodic")',
    "phi_jl": 'bilby.core.prior.Uniform(minimum=0.0, maximum=2*np.pi, boundary="periodic")',
    "geocent_time": 0.0,
}


_prior = {
    "mass_1": "bilby.core.prior.Constraint(minimum=10.0, maximum=80.0)",
    "mass_2": "bilby.core.prior.Constraint(minimum=10.0, maximum=80.0)",
    "mass_ratio": "bilby.gw.prior.UniformInComponentsMassRatio(minimum=0.125, maximum=1.0)",
    "chirp_mass": "bilby.gw.prior.UniformInComponentsChirpMass(minimum=25.0, maximum=100.0)",
    "luminosity_distance": 1000.0,
    "theta_jn": "bilby.core.prior.Sine(minimum=0.0, maximum=np.pi)",
    "phase": 'bilby.core.prior.Uniform(minimum=0.0, maximum=2*np.pi, boundary="periodic")',
    "chi_1": 'bilby.gw.prior.AlignedSpin(name="chi_1", a_prior=Uniform(minimum=0, maximum=0.99))',
    "chi_2": 'bilby.gw.prior.AlignedSpin(name="chi_2", a_prior=Uniform(minimum=0, maximum=0.99))',
    "geocent_time": 0.0,
}


def get_prior_dict(approximant: str) -> Dict:
    prior_dict = _prior_PHM if "PHM" in approximant else _prior
    priors_ = IntrinsicPriors(**prior_dict)
    priors = priors_.sample_as_dict()  # type: ignore
    return priors


def get_configuration_dict(approximant: str, f_start: Optional[float]) -> Dict:
    d: Dict = {
        "domain": {
            "type": "FrequencyDomain",
            "f_min": 10.0,
            "f_max": 1024.0,
            "delta_f": 0.125,
        },
        "waveform_generator": {
            "approximant": approximant,
            "f_ref": 20.0,
            "spin_conversion_phase": 0.0,
            "f_start": 15.0,
        },
        "intrinsic_prior": get_prior_dict(approximant),
    }
    if f_start is not None:
        d["waveform_generator"]["f_start"] = f_start
    return d


def get_original_waveform_generator(
    config_dict: Dict,
) -> Union[OriginalWaveformGenerator, NewInterfaceOriginalWaveformGenerator]:
    domain_params = config_dict["domain"]
    waveform_generator_params = config_dict["waveform_generator"]

    domain = original_build_domain(domain_params)

    if waveform_generator_params["approximant"] in _new_interface_approximants:
        kwargs = {
            "approximant": waveform_generator_params["approximant"],
            "domain": domain,
            "f_ref": waveform_generator_params["f_ref"],
            "f_start": waveform_generator_params["f_start"],
            "spin_conversion_phase": waveform_generator_params["spin_conversion_phase"],
        }
        return NewInterfaceOriginalWaveformGenerator(**kwargs)
    else:
        return OriginalWaveformGenerator(
            waveform_generator_params["approximant"],
            domain,
            waveform_generator_params["f_ref"],
            f_start=waveform_generator_params["f_start"],
            spin_conversion_phase=waveform_generator_params["spin_conversion_phase"],
        )


def get_original_priors(config_dict: Dict):
    return original_build_prior_with_defaults(config_dict["intrinsic_prior"]).sample()


def get_new_waveform_generator(config_dict: Dict) -> WaveformGenerator:
    return build_waveform_generator(config_dict)


def get_new_priors(config_dict: Dict) -> WaveformParameters:
    return IntrinsicPriors(**config_dict["intrinsic_prior"]).sample()


def get_original_polarizations(
    config_dict: Dict, approximant: str, f_start: Optional[float]
) -> Tuple[Dict, Optional[Dict]]:
    original_wfg = get_original_waveform_generator(config_dict)
    priors = get_original_priors(config_dict)
    polarizations = original_wfg.generate_hplus_hcross(priors)
    if approximant in polarization_modes_approximants:
        polarizations_modes = original_wfg.generate_hplus_hcross_m(priors)
    else:
        polarizations_modes = None
    return polarizations, polarizations_modes


def get_new_polarizations(
    config_dict: Dict, approximant: str, f_start: Optional[float]
) -> Tuple[Polarization, Optional[Dict[Mode, Polarization]]]:
    wfg = get_new_waveform_generator(config_dict)
    priors = get_new_priors(config_dict)
    polarizations = wfg.generate_hplus_hcross(priors)

    if approximant in polarization_modes_approximants:
        polarizations_modes = wfg.generate_hplus_hcross_m(priors)
    else:
        polarizations_modes = None
    return polarizations, polarizations_modes


def _main(approximant: Approximant, f_start: Optional[float]) -> str:

    config_dict = get_configuration_dict(approximant, f_start)

    original_pols, original_mode_pols = get_original_polarizations(
        config_dict, approximant, f_start
    )

    new_pols, new_mode_pols = get_new_polarizations(config_dict, approximant, f_start)

    report: List[str] = [f"\n--report for {approximant}--"]

    report.append("original polarizations")
    report.append(f"\t{original_pols["h_plus"].shape}")
    if original_mode_pols is not None:
        report.append(f"\t{list(original_mode_pols.keys())}")
    report.append("new polarizations")
    report.append(f"\t{new_pols.h_plus.shape}")
    if new_mode_pols is not None:
        report.append(f"\t{list(new_mode_pols.keys())}")
    report.append("--")
    try:
        _same(original_pols["h_plus"], new_pols.h_plus)
        _same(original_pols["h_cross"], new_pols.h_cross)
    except Exception as e:
        report.append(f"ERROR: {e}")
    else:
        report.append("OK")
    try:
        _same_modes_pols(original_mode_pols, new_mode_pols)
    except Exception as e:
        report.append(f"ERROR: {e}")
    else:
        report.append("OK")
    print("-----\n")
    # _same_modes_pols(original_mode_pols, new_mode_pols)

    return "\n".join(report)


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Compare waveforms between original and new implementations"
    )
    parser.add_argument("--approximant", type=str, help="Specific approximant to test")
    parser.add_argument("--f-start", type=float, help="Starting frequency")
    parser.add_argument("--verbose", action="store_true", help="Enable debug logging")
    args = parser.parse_args()

    set_logging(level=logging.DEBUG if args.verbose else logging.INFO)

    # Determine which approximants to test
    approximants_to_test = (
        [Approximant(args.approximant)] if args.approximant else _approximants
    )
    f_start = args.f_start if args.f_start else None

    # Run tests for each approximant
    reports: List[str] = []
    for approximant in approximants_to_test:
        print(f"\nTesting approximant: {approximant}")
        try:
            reports.append(_main(approximant, f_start))
            print(f"Successfully compared waveforms for {approximant}")
        except Exception as e:
            error = f"\n--report for {approximant}--\nError comparing waveforms for {approximant}: {str(e)}\n--"
            reports.append(error)
    for report in reports:
        print(report)


if __name__ == "__main__":
    main()
