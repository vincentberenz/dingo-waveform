"""
tmp module for comparing waveforms generated by this package and waveforms
generated by the original dingo-gw package
"""

import argparse
import contextlib
import json
import logging
import os
import tempfile
from dataclasses import dataclass, field
from itertools import product
from typing import Dict, Iterable, List, Optional, Tuple, Union

import numpy as np
from dingo.gw.domains import build_domain as original_build_domain
from dingo.gw.prior import (
    build_prior_with_defaults as original_build_prior_with_defaults,
)
from dingo.gw.waveform_generator import (
    NewInterfaceWaveformGenerator as NewInterfaceOriginalWaveformGenerator,
)
from dingo.gw.waveform_generator import WaveformGenerator as OriginalWaveformGenerator

from dingo_waveform.approximant import Approximant
from dingo_waveform.logs import set_logging
from dingo_waveform.polarizations import Polarization
from dingo_waveform.prior import IntrinsicPriors, Priors
from dingo_waveform.types import Mode
from dingo_waveform.waveform_generator import (
    WaveformGenerator,
    build_waveform_generator,
    polarization_modes_approximants,
)
from dingo_waveform.waveform_parameters import WaveformParameters

_new_interface_approximants = (Approximant("SEOBNRv5HM"), Approximant("SEOBNRv5PHM"))
_default_f_start = 10.0


@dataclass
class _Config:
    approximant: Approximant
    f_start: Optional[float]
    spin_conversion_phase: Optional[float]

    def __str__(self):
        f_start = f"{self.f_start:.2f}" if self.f_start is not None else "None"
        spin_conversion_phase = (
            f"{self.spin_conversion_phase:.2f}"
            if self.spin_conversion_phase is not None
            else "None"
        )
        return str(
            f"({self.approximant} f start: {f_start} "
            f"spin conversion_phase: {spin_conversion_phase})"
        )


@dataclass
class _Report:
    config: _Config
    error_waveforms: Optional[str]
    waveform_modes: bool
    error_waveforms_modes: Optional[str]
    main_error: Optional[str] = None


@dataclass
class _Reports:
    prior: Dict[str, Union[str, float]]
    prior_PHM: Dict[str, Union[str, float]]
    reports: List[_Report] = field(default_factory=list)

    def print(self) -> None:
        from rich import print as rprint
        from rich.console import Console
        from rich.panel import Panel
        from rich.table import Table

        console = Console()

        # Print priors in panels
        prior_panel = Panel.fit(
            "\n".join(f"{key}: {value}" for key, value in self.prior.items()),
            title="Prior",
            border_style="blue",
        )
        prior_phm_panel = Panel.fit(
            "\n".join(f"{key}: {value}" for key, value in self.prior_PHM.items()),
            title="Prior PHM",
            border_style="blue",
        )

        console.print(prior_panel)
        console.print(prior_phm_panel)

        # Create table for reports
        table = Table(title="Reports", show_header=True, header_style="bold magenta")
        table.add_column("Approximant", style="cyan")
        table.add_column("f_start", style="cyan")
        table.add_column("spin_conversion_phase", style="cyan")
        table.add_column("Main Error", style="red")
        table.add_column("Modes", style="green")
        table.add_column("waveforms", style="red")
        table.add_column("waveforms/modes", style="yellow")

        for report in self.reports:
            config = report.config
            main_error = str(report.main_error) if report.main_error else ""
            modes = "✓" if report.waveform_modes else "✗"
            error_waveforms = (
                str(report.error_waveforms) if report.error_waveforms else "✓"
            )
            error_modes = (
                str(report.error_waveforms_modes)
                if report.error_waveforms_modes
                else "✓"
            )

            table.add_row(
                str(config.approximant),
                (
                    str(config.f_start)
                    if config.f_start is not None
                    else str(_default_f_start)
                ),
                (
                    str(config.spin_conversion_phase)
                    if config.spin_conversion_phase is not None
                    else "None"
                ),
                main_error,
                modes,
                error_waveforms,
                error_modes,
            )

        console.print(table)


def _same(a: np.ndarray, b: np.ndarray, tolerance=1e-25) -> None:
    # Check if a and b are the same up to the tolerance.
    # 'same': same shape, dtype and values.
    if a.shape != b.shape:
        raise ValueError(f"Shapes do not match: {a.shape} != {b.shape}")
    if a.dtype != b.dtype:
        raise ValueError(f"Data types do not match: {a.dtype} != {b.dtype}")
    if not np.allclose(a, b, atol=tolerance):
        raise ValueError("Arrays are not close enough within the given tolerance.")


def _same_modes_pols(a: Optional[Dict], b: Optional[Dict[Mode, Polarization]]) -> bool:
    if a is None or b is None:
        return False
    if set(a.keys()) != set(b.keys()):
        raise ValueError("Keys of the dictionaries do not match.")
    for mode in a.keys():
        _same(a[mode]["h_plus"], b[mode].h_plus)
        _same(a[mode]["h_cross"], b[mode].h_cross)
    return True


@contextlib.contextmanager
def config_file_json(config_dict):
    """Create a temporary JSON config file and ensure its deletion."""
    tmp_dir = tempfile.mkdtemp()
    try:
        file_path = os.path.join(tmp_dir, "config.json")
        with open(file_path, "w") as f:
            json.dump(config_dict, f)
        yield file_path
    finally:
        os.remove(file_path)
        os.rmdir(tmp_dir)


_prior_PHM: Dict[str, Union[str, float]] = {
    "mass_1": "bilby.core.prior.Constraint(minimum=10.0, maximum=80.0)",
    "mass_2": "bilby.core.prior.Constraint(minimum=10.0, maximum=80.0)",
    "mass_ratio": "bilby.gw.prior.UniformInComponentsMassRatio(minimum=0.125, maximum=1.0)",
    "chirp_mass": "bilby.gw.prior.UniformInComponentsChirpMass(minimum=25.0, maximum=100.0)",
    "luminosity_distance": 1000.0,
    "theta_jn": "bilby.core.prior.Sine(minimum=0.0, maximum=np.pi)",
    "phase": 'bilby.core.prior.Uniform(minimum=0.0, maximum=2*np.pi, boundary="periodic")',
    "a_1": "bilby.core.prior.Uniform(minimum=0.0, maximum=0.99)",
    "a_2": "bilby.core.prior.Uniform(minimum=0.0, maximum=0.99)",
    "tilt_1": "bilby.core.prior.Sine(minimum=0.0, maximum=np.pi)",
    "tilt_2": "bilby.core.prior.Sine(minimum=0.0, maximum=np.pi)",
    "phi_12": 'bilby.core.prior.Uniform(minimum=0.0, maximum=2*np.pi, boundary="periodic")',
    "phi_jl": 'bilby.core.prior.Uniform(minimum=0.0, maximum=2*np.pi, boundary="periodic")',
    "geocent_time": 0.0,
}


_prior: Dict[str, Union[str, float]] = {
    "mass_1": "bilby.core.prior.Constraint(minimum=10.0, maximum=80.0)",
    "mass_2": "bilby.core.prior.Constraint(minimum=10.0, maximum=80.0)",
    "mass_ratio": "bilby.gw.prior.UniformInComponentsMassRatio(minimum=0.125, maximum=1.0)",
    "chirp_mass": "bilby.gw.prior.UniformInComponentsChirpMass(minimum=25.0, maximum=100.0)",
    "luminosity_distance": 1000.0,
    "theta_jn": "bilby.core.prior.Sine(minimum=0.0, maximum=np.pi)",
    "phase": 'bilby.core.prior.Uniform(minimum=0.0, maximum=2*np.pi, boundary="periodic")',
    "chi_1": 'bilby.gw.prior.AlignedSpin(name="chi_1", a_prior=Uniform(minimum=0, maximum=0.99))',
    "chi_2": 'bilby.gw.prior.AlignedSpin(name="chi_2", a_prior=Uniform(minimum=0, maximum=0.99))',
    "geocent_time": 0.0,
}


def get_prior_dict(approximant: str) -> Dict:
    prior_dict = _prior_PHM if "PHM" in approximant else _prior
    priors_ = IntrinsicPriors(**prior_dict)
    priors = priors_.sample_as_dict()  # type: ignore
    return priors


def get_configuration_dict(config: _Config) -> Dict:
    d: Dict = {
        "domain": {
            "type": "FrequencyDomain",
            "f_min": 10.0,
            "f_max": 1024.0,
            "delta_f": 0.125,
        },
        "waveform_generator": {
            "approximant": config.approximant,
            "f_ref": 20.0,
            "f_start": _default_f_start,
            "spin_conversion_phase": config.spin_conversion_phase,
        },
        "intrinsic_prior": get_prior_dict(config.approximant),
    }
    if config.f_start is not None:
        d["waveform_generator"]["f_start"] = config.f_start
    return d


def get_original_waveform_generator(
    config_dict: Dict,
) -> Union[OriginalWaveformGenerator, NewInterfaceOriginalWaveformGenerator]:
    domain_params = config_dict["domain"]
    waveform_generator_params = config_dict["waveform_generator"]

    domain = original_build_domain(domain_params)

    if waveform_generator_params["approximant"] in _new_interface_approximants:
        kwargs = {
            "approximant": waveform_generator_params["approximant"],
            "domain": domain,
            "f_ref": waveform_generator_params["f_ref"],
            "f_start": waveform_generator_params["f_start"],
            "spin_conversion_phase": waveform_generator_params["spin_conversion_phase"],
        }
        return NewInterfaceOriginalWaveformGenerator(**kwargs)
    else:
        return OriginalWaveformGenerator(
            waveform_generator_params["approximant"],
            domain,
            waveform_generator_params["f_ref"],
            f_start=waveform_generator_params["f_start"],
            spin_conversion_phase=waveform_generator_params["spin_conversion_phase"],
        )


def get_original_priors(config_dict: Dict):
    return original_build_prior_with_defaults(config_dict["intrinsic_prior"]).sample()


def get_new_waveform_generator(config_dict: Dict) -> WaveformGenerator:
    return build_waveform_generator(config_dict)


def get_new_priors(config_dict: Dict) -> WaveformParameters:
    return IntrinsicPriors(**config_dict["intrinsic_prior"]).sample()


def get_original_polarizations(
    config_dict: Dict, approximant: str
) -> Tuple[Dict, Optional[Dict]]:
    original_wfg = get_original_waveform_generator(config_dict)
    priors = get_original_priors(config_dict)
    polarizations = original_wfg.generate_hplus_hcross(priors)
    if approximant in polarization_modes_approximants:
        polarizations_modes = original_wfg.generate_hplus_hcross_m(priors)
    else:
        polarizations_modes = None
    return polarizations, polarizations_modes


def get_new_polarizations(
    config_dict: Dict, approximant: str
) -> Tuple[Polarization, Optional[Dict[Mode, Polarization]]]:
    wfg = get_new_waveform_generator(config_dict)
    priors = get_new_priors(config_dict)
    polarizations = wfg.generate_hplus_hcross(priors)

    if approximant in polarization_modes_approximants:
        polarizations_modes = wfg.generate_hplus_hcross_m(priors)
    else:
        polarizations_modes = None
    return polarizations, polarizations_modes


def _main(config: _Config) -> _Report:

    config_dict = get_configuration_dict(config)

    original_pols, original_mode_pols = get_original_polarizations(
        config_dict, config.approximant
    )

    new_pols, new_mode_pols = get_new_polarizations(config_dict, config.approximant)

    error_waveforms: Optional[str] = None
    try:
        _same(original_pols["h_plus"], new_pols.h_plus)
        _same(original_pols["h_cross"], new_pols.h_cross)
    except Exception as e:
        error_waveforms = str(e)

    error_waveforms_modes: Optional[str] = None
    try:
        waveform_modes: bool = _same_modes_pols(original_mode_pols, new_mode_pols)
    except Exception as e:
        error_waveforms_modes = str(e)

    return _Report(config, error_waveforms, waveform_modes, error_waveforms_modes)


def _get_configs(
    approximants: Iterable[Approximant],
    f_start: Iterable[Optional[float]],
    spin_conversion_phase: Iterable[Optional[float]],
) -> List[_Config]:
    return [
        _Config(a, f, s)
        for a, f, s in product(approximants, f_start, spin_conversion_phase)
    ]


_approximants = (
    Approximant("IMRPhenomPv2"),
    Approximant("IMRPhenomXPHM"),
    Approximant("SEOBNRv4PHM"),
    Approximant("SEOBNRv5PHM"),
    Approximant("SEOBNRv5HM"),
)
_f_start = (None, 15.0)
_spin_conversion_phase = (0.0, 0.2)


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Compare waveforms between original and new implementations"
    )
    parser.add_argument("--approximant", type=str, help="Specific approximant to test")
    parser.add_argument(
        "--fstart", type=float, help="Specific frequency start value to test"
    )
    parser.add_argument(
        "--scp", type=float, help="Specific spin conversion phase value to test"
    )
    parser.add_argument("--verbose", action="store_true", help="Enable debug logging")
    args = parser.parse_args()

    set_logging(level=logging.DEBUG if args.verbose else logging.INFO)

    # Determine which approximants to test
    approximants = (
        [Approximant(args.approximant)] if args.approximant else _approximants
    )
    f_starts = [args.fstart] if args.fstart else _f_start
    scp = [args.scp] if args.scp is not None else _spin_conversion_phase

    configs = _get_configs(approximants, f_starts, scp)

    # Run tests for each approximant
    reports = _Reports(prior=_prior, prior_PHM=_prior_PHM)
    for config in configs:
        print(
            f"\nTesting: {config.approximant} f_start: {config.f_start} spin conversion phase: {config.spin_conversion_phase}"
        )
        report: _Report
        try:
            report = _main(config)
        except Exception as e:
            report = _Report(config, None, False, None, main_error=str(e))
        reports.reports.append(report)

    reports.print()


if __name__ == "__main__":
    main()
