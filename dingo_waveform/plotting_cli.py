#!/usr/bin/env python3
"""
Command-line interface for plotting waveforms generated by dingo-waveform.

This tool generates waveforms from a JSON configuration file and creates
interactive plots for visualization and diagnostics.
"""
import argparse
import json
import sys
from pathlib import Path
from typing import Dict, Any, Optional

from .approximant import Approximant
from .domains import TimeDomain, UniformFrequencyDomain, MultibandedFrequencyDomain
from .waveform_generator import WaveformGenerator
from .waveform_parameters import WaveformParameters
from .plotting import (
    plot_polarizations_time,
    plot_polarizations_frequency,
    plot_polarization_spectrogram,
    plot_polarization_qtransform,
    plot_mode_amplitudes,
    plot_individual_modes,
    plot_mode_comparison,
    plot_modes_grid,
)


def load_config(config_path: str) -> Dict[str, Any]:
    """
    Load configuration from JSON file.

    Parameters
    ----------
    config_path : str
        Path to JSON configuration file

    Returns
    -------
    dict
        Configuration dictionary
    """
    path = Path(config_path)
    if not path.exists():
        raise FileNotFoundError(f"Configuration file not found: {config_path}")

    with open(path, 'r') as f:
        config = json.load(f)

    return config


def validate_config(config: Dict[str, Any]) -> None:
    """
    Validate configuration has required fields.

    Parameters
    ----------
    config : dict
        Configuration dictionary

    Raises
    ------
    ValueError
        If configuration is missing required fields
    """
    required_fields = ['domain', 'waveform_generator', 'waveform_parameters']
    missing = [f for f in required_fields if f not in config]

    if missing:
        raise ValueError(
            f"Configuration missing required fields: {', '.join(missing)}\n"
            f"Required fields: {', '.join(required_fields)}"
        )

    # Validate domain
    if 'type' not in config['domain']:
        raise ValueError("domain.type is required")

    # Validate waveform_generator
    if 'approximant' not in config['waveform_generator']:
        raise ValueError("waveform_generator.approximant is required")

    # Validate waveform_parameters
    if not isinstance(config['waveform_parameters'], dict):
        raise ValueError("waveform_parameters must be a dictionary")


def create_domain(domain_config: Dict[str, Any]):
    """
    Create domain object from configuration.

    Parameters
    ----------
    domain_config : dict
        Domain configuration with 'type' and domain parameters

    Returns
    -------
    Domain
        Domain object (TimeDomain, UniformFrequencyDomain, or MultibandedFrequencyDomain)
    """
    domain_type = domain_config['type'].lower()
    params = {k: v for k, v in domain_config.items() if k != 'type'}

    if 'time' in domain_type:
        return TimeDomain(**params)
    elif 'multibanded' in domain_type:
        return MultibandedFrequencyDomain(**params)
    else:
        return UniformFrequencyDomain(**params)


def create_waveform_generator(
    wfg_config: Dict[str, Any],
    domain
) -> WaveformGenerator:
    """
    Create WaveformGenerator from configuration.

    Parameters
    ----------
    wfg_config : dict
        Waveform generator configuration
    domain : Domain
        Domain object

    Returns
    -------
    WaveformGenerator
        Configured waveform generator
    """
    return WaveformGenerator(
        approximant=Approximant(wfg_config['approximant']),
        domain=domain,
        f_ref=wfg_config.get('f_ref', 20.0),
        f_start=wfg_config.get('f_start'),
        spin_conversion_phase=wfg_config.get('spin_conversion_phase', 0.0),
    )


def create_waveform_parameters(params_config: Dict[str, Any]) -> WaveformParameters:
    """
    Create WaveformParameters from configuration.

    Parameters
    ----------
    params_config : dict
        Waveform parameters configuration

    Returns
    -------
    WaveformParameters
        Waveform parameters object
    """
    return WaveformParameters(**params_config)


def save_or_show_plot(fig, filename: Optional[str], show: bool):
    """
    Save plot to file and/or display it.

    Parameters
    ----------
    fig : plotly.graph_objects.Figure
        Plotly figure to save/show
    filename : str or None
        If provided, save to this filename
    show : bool
        If True, display the plot in browser
    """
    if filename:
        fig.write_html(filename)
        print(f"  ✓ Saved to {filename}")

    if show:
        fig.show()


def plot_basic_polarizations(
    wfg: WaveformGenerator,
    params: WaveformParameters,
    domain,
    output_dir: Path,
    show: bool
):
    """
    Generate and plot basic polarizations (from generate_hplus_hcross).

    Parameters
    ----------
    wfg : WaveformGenerator
        Waveform generator
    params : WaveformParameters
        Waveform parameters
    domain : Domain
        Domain object
    output_dir : Path
        Output directory for plots
    show : bool
        Whether to display plots
    """
    print("\nGenerating basic polarizations...")
    pol = wfg.generate_hplus_hcross(params)
    print(f"  h_plus shape: {pol.h_plus.shape}")
    print(f"  h_cross shape: {pol.h_cross.shape}")

    # Determine domain type
    domain_type = None
    if isinstance(domain, TimeDomain):
        domain_type = "time"
    elif isinstance(domain, (UniformFrequencyDomain, MultibandedFrequencyDomain)):
        domain_type = "frequency"

    print("\nCreating polarization plots...")

    # Time domain plots
    if domain_type == "time":
        fig1 = plot_polarizations_time(pol, domain)
        save_or_show_plot(fig1, output_dir / "polarizations_time.html", show)

        print("  Creating spectrogram...")
        fig2 = plot_polarization_spectrogram(pol, domain)
        save_or_show_plot(fig2, output_dir / "spectrogram.html", show)

        print("  Creating Q-transform...")
        fig3 = plot_polarization_qtransform(pol, domain)
        save_or_show_plot(fig3, output_dir / "qtransform.html", show)

    # Frequency domain plots
    elif domain_type == "frequency":
        fig1 = plot_polarizations_frequency(pol, domain, plot_type="amplitude")
        save_or_show_plot(fig1, output_dir / "polarizations_amplitude.html", show)

        fig2 = plot_polarizations_frequency(pol, domain, plot_type="both")
        save_or_show_plot(fig2, output_dir / "polarizations_both.html", show)


def plot_mode_separated(
    wfg: WaveformGenerator,
    params: WaveformParameters,
    domain,
    output_dir: Path,
    show: bool
):
    """
    Generate and plot mode-separated polarizations (from generate_hplus_hcross_m).

    Parameters
    ----------
    wfg : WaveformGenerator
        Waveform generator
    params : WaveformParameters
        Waveform parameters
    domain : Domain
        Domain object
    output_dir : Path
        Output directory for plots
    show : bool
        Whether to display plots
    """
    print("\nGenerating mode-separated polarizations...")
    modes = wfg.generate_hplus_hcross_m(params)
    print(f"  Number of modes: {len(modes)}")
    print(f"  Modes: {sorted(modes.keys())}")

    print("\nCreating mode plots...")

    # Mode amplitude comparison
    fig1 = plot_mode_amplitudes(modes, domain)
    save_or_show_plot(fig1, output_dir / "mode_amplitudes.html", show)

    # Individual modes overlaid
    fig2 = plot_individual_modes(
        modes,
        domain,
        domain_type="time" if isinstance(domain, TimeDomain) else "frequency"
    )
    save_or_show_plot(fig2, output_dir / "individual_modes.html", show)

    # Mode comparison (side-by-side)
    if len(modes) > 1:
        # Use the mode with largest absolute m as reference (typically dominant mode)
        reference_mode = max(modes.keys(), key=abs)
        fig3 = plot_mode_comparison(modes, domain, reference_mode=reference_mode)
        save_or_show_plot(fig3, output_dir / "mode_comparison.html", show)

    # Modes grid
    if len(modes) > 2:
        fig4 = plot_modes_grid(
            modes,
            domain,
            domain_type="time" if isinstance(domain, TimeDomain) else "frequency"
        )
        save_or_show_plot(fig4, output_dir / "modes_grid.html", show)


def main():
    """Main entry point for CLI."""
    parser = argparse.ArgumentParser(
        description="Generate and plot waveforms from dingo-waveform",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Use config.json in current directory, plot basic polarizations
  dingo-plot

  # Specify config file path
  dingo-plot --config /path/to/config.json

  # Plot mode-separated waveforms
  dingo-plot --modes

  # Save plots without displaying
  dingo-plot --output plots/

  # Display plots in browser
  dingo-plot --show

  # Both save and display
  dingo-plot --output plots/ --show

Configuration File Format:
  Uses the same format as dingo-verify:
  {
    "domain": {
      "type": "UniformFrequencyDomain" or "MultibandedFrequencyDomain" or "TimeDomain",
      "delta_f": 0.125,  # for frequency domains
      "delta_t": 0.1,    # for time domain
      "f_min": 20.0,
      "f_max": 1024.0,
      "duration": 8.0    # for time domain
    },
    "waveform_generator": {
      "approximant": "IMRPhenomXPHM",
      "f_ref": 20.0,
      "f_start": 20.0
    },
    "waveform_parameters": {
      "mass_1": 36.0,
      "mass_2": 29.0,
      "luminosity_distance": 1000.0,
      ...
    }
  }
        """
    )

    parser.add_argument(
        '--config', '-c',
        default='config.json',
        help='Path to JSON configuration file (default: config.json)'
    )
    parser.add_argument(
        '--modes', '-m',
        action='store_true',
        help='Plot mode-separated waveforms (generate_hplus_hcross_m) instead of basic polarizations. Only works with PHM/HM approximants.'
    )
    parser.add_argument(
        '--output', '-o',
        default='.',
        help='Output directory for plot HTML files (default: current directory)'
    )
    parser.add_argument(
        '--show', '-s',
        action='store_true',
        help='Display plots in browser (in addition to saving them)'
    )

    args = parser.parse_args()

    try:
        # Load and validate configuration
        print(f"Loading configuration from: {args.config}")
        config = load_config(args.config)
        validate_config(config)

        # Create output directory
        output_dir = Path(args.output)
        output_dir.mkdir(parents=True, exist_ok=True)

        # Extract configuration
        domain_config = config['domain']
        wfg_config = config['waveform_generator']
        params_config = config['waveform_parameters']

        # Create domain
        print(f"\nCreating domain: {domain_config['type']}")
        domain = create_domain(domain_config)

        # Create waveform generator
        print(f"Creating waveform generator: {wfg_config['approximant']}")
        wfg = create_waveform_generator(wfg_config, domain)

        # Create waveform parameters
        print("Creating waveform parameters...")
        params = create_waveform_parameters(params_config)

        # Generate and plot
        if args.modes:
            plot_mode_separated(wfg, params, domain, output_dir, args.show)
        else:
            plot_basic_polarizations(wfg, params, domain, output_dir, args.show)

        print("\n" + "=" * 80)
        print("✓ Plotting complete!")
        print(f"✓ Plots saved to: {output_dir.absolute()}")
        print("=" * 80)

        sys.exit(0)

    except FileNotFoundError as e:
        print(f"\n❌ Error: {e}", file=sys.stderr)
        sys.exit(1)
    except ValueError as e:
        print(f"\n❌ Configuration Error: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"\n❌ Unexpected Error: {e}", file=sys.stderr)
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
