#!/usr/bin/env python3
"""
Command-line interface for verifying dingo-waveform against dingo (dingo-gw).

This tool compares waveforms generated by both packages to verify scientific correctness.
"""
import argparse
import json
import sys
from pathlib import Path
from typing import Dict, Any

import numpy as np

from .comparison import compare_waveforms, compare_waveforms_modes
from .prior import IntrinsicPriors


def load_config(config_path: str) -> Dict[str, Any]:
    """
    Load configuration from JSON file.

    Parameters
    ----------
    config_path : str
        Path to JSON configuration file

    Returns
    -------
    dict
        Configuration dictionary
    """
    path = Path(config_path)
    if not path.exists():
        raise FileNotFoundError(f"Configuration file not found: {config_path}")

    with open(path, 'r') as f:
        config = json.load(f)

    return config


def validate_config(config: Dict[str, Any]) -> None:
    """
    Validate configuration has required fields.

    Parameters
    ----------
    config : dict
        Configuration dictionary

    Raises
    ------
    ValueError
        If configuration is missing required fields
    """
    required_fields = ['domain', 'waveform_generator', 'waveform_parameters']
    missing = [f for f in required_fields if f not in config]

    if missing:
        raise ValueError(
            f"Configuration missing required fields: {', '.join(missing)}\n"
            f"Required fields: {', '.join(required_fields)}"
        )

    # Validate domain
    if 'type' not in config['domain']:
        raise ValueError("domain.type is required")

    # Validate waveform_generator
    if 'approximant' not in config['waveform_generator']:
        raise ValueError("waveform_generator.approximant is required")

    # Validate waveform_parameters
    if not isinstance(config['waveform_parameters'], dict):
        raise ValueError("waveform_parameters must be a dictionary")


def build_prior_from_params(params: Dict[str, Any]) -> IntrinsicPriors:
    """
    Build IntrinsicPriors from waveform parameters.

    For single-sample comparison, we just need fixed values,
    so we set each parameter as a fixed value.

    Parameters
    ----------
    params : dict
        Waveform parameters

    Returns
    -------
    IntrinsicPriors
        Prior object with fixed parameters
    """
    return IntrinsicPriors(**params)


def display_comparison(result, verbose: bool = False):
    """
    Display comparison results to terminal.

    Parameters
    ----------
    result : WaveformComparisonResult
        Comparison result
    verbose : bool
        If True, display detailed information
    """
    print("\n" + "=" * 80)
    print("WAVEFORM VERIFICATION RESULTS")
    print("=" * 80)

    # Domain info
    print(f"\n{'Domain Type:':<20} {result.dingo_domain_type}")
    print(f"{'Length:':<20} {result.dingo_domain_len} bins")
    print(f"{'Frequency Range:':<20} {result.dingo_f_min:.2f} - {result.dingo_f_max:.2f} Hz")

    # Shape comparison
    print(f"\n{'Shape Match:':<20} {'✅ YES' if result.shapes_match else '❌ NO'}")
    if not result.shapes_match:
        print(f"{'  dingo shape:':<20} {result.dingo_shape}")
        print(f"{'  dingo-waveform:':<20} {result.refactored_shape}")
        print("\n❌ VERIFICATION FAILED: Shape mismatch")
        return

    # Numerical comparison
    if result.max_diff_h_plus is not None:
        print(f"\n{'Absolute Differences:':<20}")
        print(f"  {'h_plus  max:':<18} {result.max_diff_h_plus:.2e}")
        print(f"  {'h_plus  mean:':<18} {result.mean_diff_h_plus:.2e}")
        print(f"  {'h_cross max:':<18} {result.max_diff_h_cross:.2e}")
        print(f"  {'h_cross mean:':<18} {result.mean_diff_h_cross:.2e}")

        print(f"\n{'Relative Differences:':<20}")
        print(f"  {'h_plus  max:':<18} {result.max_rel_diff_h_plus:.2e}")
        print(f"  {'h_cross max:':<18} {result.max_rel_diff_h_cross:.2e}")

        # Determine if verification passed
        tolerance = 1e-15  # Machine precision level
        max_diff = max(result.max_diff_h_plus, result.max_diff_h_cross)

        print(f"\n{'Tolerance:':<20} {tolerance:.2e}")
        print(f"{'Max Difference:':<20} {max_diff:.2e}")

        if max_diff < tolerance:
            print("\n" + "✅ " * 20)
            print("✅ VERIFICATION PASSED")
            print("✅ dingo-waveform produces IDENTICAL results to dingo (dingo-gw)")
            print("✅ " * 20)
        elif max_diff < 1e-10:
            print("\n⚠️  VERIFICATION ACCEPTABLE")
            print(f"⚠️  Differences are small ({max_diff:.2e}) but above machine precision")
            print("⚠️  This may be acceptable depending on use case")
        else:
            print("\n❌ " * 20)
            print("❌ VERIFICATION FAILED")
            print(f"❌ Differences ({max_diff:.2e}) exceed acceptable tolerance")
            print("❌ " * 20)

    if verbose:
        print("\n" + "-" * 80)
        print("DETAILED OUTPUT")
        print("-" * 80)
        print(result)

    print("\n" + "=" * 80)


def main():
    """Main entry point for CLI."""
    parser = argparse.ArgumentParser(
        description="Verify dingo-waveform against dingo (dingo-gw)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Use config.json in current directory
  dingo-verify

  # Specify config file path
  dingo-verify --config /path/to/config.json

  # Verbose output
  dingo-verify --config config.json --verbose

Configuration File Format:
  {
    "domain": {
      "type": "UniformFrequencyDomain" or "MultibandedFrequencyDomain",
      "delta_f": 0.125,
      "f_min": 20.0,
      "f_max": 1024.0
    },
    "waveform_generator": {
      "approximant": "IMRPhenomXPHM",
      "f_ref": 20.0,
      "f_start": 20.0
    },
    "waveform_parameters": {
      "mass_1": 36.0,
      "mass_2": 29.0,
      "luminosity_distance": 1000.0,
      ...
    }
  }
        """
    )

    parser.add_argument(
        '--config', '-c',
        default='config.json',
        help='Path to JSON configuration file (default: config.json)'
    )
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        help='Display detailed comparison output'
    )
    parser.add_argument(
        '--seed', '-s',
        type=int,
        default=None,
        help='Random seed for parameter sampling (if using priors)'
    )
    parser.add_argument(
        '--modes', '-m',
        action='store_true',
        help='Compare mode-separated waveforms (generate_hplus_hcross_m) instead of total polarizations. Only works with PHM/HM approximants.'
    )

    args = parser.parse_args()

    try:
        # Load and validate configuration
        print(f"Loading configuration from: {args.config}")
        config = load_config(args.config)
        validate_config(config)

        # Set random seed if provided
        if args.seed is not None:
            np.random.seed(args.seed)
            print(f"Random seed set to: {args.seed}")

        # Extract configuration
        domain_params = config['domain']
        wfg_config = config['waveform_generator']
        waveform_params = config['waveform_parameters']

        # Determine domain type
        domain_type = domain_params['type'].lower()
        if 'multibanded' in domain_type:
            domain_type = 'multibanded'
        else:
            domain_type = 'uniform'

        print(f"Domain type: {domain_type}")
        print(f"Approximant: {wfg_config['approximant']}")

        # Prepare domain parameters (remove 'type' key for comparison function)
        domain_params_clean = {k: v for k, v in domain_params.items() if k != 'type'}

        # Generate and compare waveforms
        if args.modes:
            print("\nGenerating mode-separated waveforms...")
            print("  - Using dingo (dingo-gw) generate_hplus_hcross_m()...")
            print("  - Using dingo-waveform generate_hplus_hcross_m()...")

            result = compare_waveforms_modes(
                domain_type=domain_type,
                domain_params=domain_params_clean,
                approximant=wfg_config['approximant'],
                waveform_params=waveform_params,
                f_ref=wfg_config.get('f_ref', 20.0),
                f_start=wfg_config.get('f_start'),
                spin_conversion_phase=wfg_config.get('spin_conversion_phase', 0.0),
            )
        else:
            print("\nGenerating waveforms...")
            print("  - Using dingo (dingo-gw)...")
            print("  - Using dingo-waveform...")

            result = compare_waveforms(
                domain_type=domain_type,
                domain_params=domain_params_clean,
                approximant=wfg_config['approximant'],
                waveform_params=waveform_params,
                f_ref=wfg_config.get('f_ref', 20.0),
                f_start=wfg_config.get('f_start'),
                spin_conversion_phase=wfg_config.get('spin_conversion_phase', 0.0),
            )

        # Display results
        display_comparison(result, verbose=args.verbose)

        # Exit with appropriate code
        if not result.shapes_match:
            sys.exit(1)

        if result.max_diff_h_plus is not None:
            max_diff = max(result.max_diff_h_plus, result.max_diff_h_cross)
            if max_diff > 1e-10:
                sys.exit(1)

        sys.exit(0)

    except FileNotFoundError as e:
        print(f"\n❌ Error: {e}", file=sys.stderr)
        sys.exit(1)
    except ValueError as e:
        print(f"\n❌ Configuration Error: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"\n❌ Unexpected Error: {e}", file=sys.stderr)
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
